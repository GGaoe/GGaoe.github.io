<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="Learning,Life,高歌,Gaoge" />
       
      <meta name="description" content="be yourself" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Crypto笔记 |  GaoGe&#39;s Homepage</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Crypto"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Crypto笔记
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/09/20/Crypto/" class="article-date">
  <time datetime="2024-09-20T03:40:37.136Z" itemprop="datePublished">2024-09-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Learning/">Learning</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">18 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="introduction">Introduction</h3>
<p>凯撒移位密码：key space太小</p>
<p>单字母替代密码：一个字母的加密方式总是一样的，统计攻击破解，如果我们知道一个字母在明文中出现的频率，就可以极大缩小明文的搜索空间</p>
<p>替代方法：多字母替换</p>
<p>維吉尼亞密碼 or 多字母移位密碼：是多密码替换的特殊情况
破解方式：先确定加密密钥的长度m，然后break出m个加密密钥（统计攻击破解）</p>
<h3 id="perfect-secrecy完美保密性">Perfect Secrecy（完美保密性）</h3>
<h4 id="defining-an-encryption-scheme">Defining an encryption
scheme</h4>
<p><img src="/2024/09/20/Crypto/pic1.png"></p>
<p>密文空间 M 上的一个加密算法 (Gen, Enc, Dec) 是完美保密的，如果对于 M
上的每个分布都有 <span class="math inline">\(Pr[M=m|C=c]=Pr[M=m]\)</span>，对于每个 <span class="math inline">\(m \in M\)</span> 和每个 <span class="math inline">\(c \in C\)</span>，且 <span class="math inline">\(Pr[C = c] &gt; 0\)</span>。</p>
<p>可以用贝叶斯公式等完成证明；</p>
<p>完美保密性含义：不会因为知道密文而获取到明文的任何信息。</p>
<h4 id="一个等效的完美保密性的定义">一个等效的完美保密性的定义:</h4>
<p>一种加密方案 (Gen, Enc, Dec) 在消息空间 M
上是完全保密的，当且仅当对于每个 m, m′ ∈ M 和每个 c ∈ C：<span class="math inline">\(Pr[C = c|M = m] = Pr[C = c|M = m′]\)</span></p>
<p>密文的分布相对于明文是独立的</p>
<h4 id="完美不可分辨性">完美不可分辨性：</h4>
<p>A向B发送两组明文<span class="math inline">\(m_1,m_2\)</span>,B通过Gen获取一个密钥k，并均匀随机的抽取明文中的其中一个n进行加密，将加密后的密文传给A。通过获取到的密文c，A猜测n是第一位还是第二位。如果猜对了，则<span class="math inline">\(PrivK^{eav}_{A,\Pi}=1\)</span> <img src="/2024/09/20/Crypto/pic2.png"> 有完美保密性当且仅当有完美不可分辨性</p>
<h4 id="一次一密">一次一密：</h4>
<p>只有密码只使用一次和只知密文时有保密性</p>
<h4 id="完美保密性的限制">完美保密性的限制：</h4>
<p>必须要求|K|&gt;=|M|</p>
<h4 id="香农定理">香农定理：</h4>
<p>一个加密算法，有|M|=|K|=|C|,当且仅当满足下列性质时，算法是完美保密的：
Gen选取密钥是对于每一个密钥k，都以相同的概率<span class="math inline">\(\frac{1}{|K|}\)</span>获取
对于每一个明文m和密文c，存在一个唯一的密钥k，使得<span class="math inline">\(Enc_k(m)\)</span> 输出c</p>
<h3 id="计算安全理论">计算安全理论</h3>
<p>计算安全性的渐进方法 有效的对手 = 随机算法 + 多项式时间 有界 =
概率多项式时间Probabilistic Polynomial-Time（有界）算法= PPT 算法</p>
<p>一个从自然数到非负实数的函数 negl(·)
是可忽略的，如果对于每一个正多项式 p，都存在一个 N，使得对于所有整数
<span class="math inline">\(n &gt; N，negl(n) &lt; 1/p(n)\)</span>。
一个从自然数到非负实数的函数 negl(·) 是可忽略的，如果对于每一个正整数
c，都存在一个 <span class="math inline">\(N_c\)</span>，使得对于所有整数
<span class="math inline">\(n &gt; N_c，negl(n) &lt;
1/n^c\)</span>。</p>
<p>设<span class="math inline">\(negl_1\)</span> 和 <span class="math inline">\(negl_2\)</span>是可忽略函数。那么， 1.
如果存在一个整数 <span class="math inline">\(N_c\)</span> 使得对于所有
<span class="math inline">\(n ≥ N_c，f(n) &lt; negl_1(n)\)</span>
成立，则 f(n) 是可忽略的。</p>
<ol start="2" type="1">
<li><p>函数 <span class="math inline">\(negl_3(n) = negl_1(n) +
negl_2(n)\)</span> 也是可忽略的。</p></li>
<li><p>对于任何正多项式 p，定义函数 <span class="math inline">\(negl_4\)</span> 为 <span class="math inline">\(negl4(n) = p(n) · negl_1(n)\)</span>，则 <span class="math inline">\(negl_4\)</span> 也是可忽略的。</p></li>
</ol>
<p>一个方案是安全的，如果对于每一个多项式时间有界对手 A
进行某种形式上指定类型的攻击，A 成功攻击的概率是可忽略的。</p>
<p>等价定义：一个方案是安全的，如果对于每一个多项式时间有界对手 A
进行某种形式上指定类型的攻击，并且对于每一个正多项式 p，存在一个整数
N，使得当 n &gt; N 时，A 成功攻击的概率小于 <span class="math inline">\(\frac{1}{p(n)}\)</span>。</p>
<h4 id="indistinguishable-encryptions-in-the-presence-of-an-eavesdropper-or-eav-secure">indistinguishable
encryptions in the presence of an eavesdropper or EAV-secure</h4>
<p>对于任意n，存在一个可以忽略的函数negl，使得 <span class="math display">\[Pr[PrivK^{env}_{A,\Pi}=1]\leq
\frac{1}{2}+negl(n)\]</span> 一个等效的定义： <span class="math display">\[Pr[out_A(PrivK^{env}_{A,\Pi}(n,0))=1]-Pr[out_A(PrivK^{env}_{A,\Pi}(n,1))=1]\leq
negl(n)\]</span> 其中<span class="math inline">\(PrivK^{env}_{A,\Pi}(n,b)\)</span>表示在不可区分性实验中使用一个固定的b，并且out代表A的输出。</p>
<h3 id="构建在计算上安全的加密">构建在计算上安全的加密</h3>
<h4 id="伪随机数发生器">伪随机数发生器</h4>
<p>令l(·)是一个多项式，令G是一个确定多项式时间算法，该算法满足：对于任意输入<span class="math inline">\(s=\{0,1\}^n\)</span>,算法输出一个长度为l(n)的字符串，如果满足下列两个条件，则称G是一个伪随机发生器：</p>
<p>1.扩展性：对于每个n来说，l(n)&gt;n</p>
<p>2.伪随机性：对于所有的概率随机性多项式时间的区分器D来说，存在一个可忽略函数negl，满足
<span class="math display">\[|Pr[D(r)=1]-Pr[D(G(s))=1]|\leq
negl(n)\]</span> 其中r是从<span class="math inline">\(\{0,1\}^l(n)\)</span>中均匀随机选择的，种子s是从<span class="math inline">\(\{0,1\}^n\)</span>中选择的。</p>
<h4 id="用伪随机数发生器构造的一次一密是eav安全的">用伪随机数发生器构造的一次一密是EAV安全的</h4>
<p>证明方法是用规约，已知伪随机数发生器和真随机之间是eav安全的，无法用PPT算法来分辨，那么：</p>
<p>假设构造的一次一密<span class="math inline">\(Pr[Privk^{eav}_{A,\pi}=1]=\frac{1}{2}+\epsilon(n)\)</span></p>
<p>我们要证<span class="math inline">\(\epsilon(n)\leq
negl(n)\)</span>,否则存在一个算法可以区分伪随机数和真随机</p>
<p>于是通过这两种一次一密构建了一个区分器D</p>
<p>当w=r时，<span class="math inline">\(Pr[D[w]=1]=Pr[D[r]]=Pr[Privk^{eav}_{A,\hat{\pi}}=1]=\frac{1}{2}\)</span></p>
<p>当w=G(n)时，<span class="math inline">\(Pr[D[w]=1]=Pr[D[G[n]]=1]=Pr[Privk^{eav}_{A,\pi}=1]=\frac{1}{2}+\epsilon(n)\)</span></p>
<p>其中第二个等号成立，是由于D就是由A构造出来的函数，通过A的输出来充当D的输出，所以两个函数的输出其实是相同的。</p>
<p>所以<span class="math inline">\(|Pr[D[r]]-Pr[D[G[n]]]|=\epsilon(n)\)</span></p>
<p>由伪随机数发生器的定义，<span class="math inline">\(\epsilon(n)\leq
negl(n)\)</span></p>
<p>所以构造出来的一次一密<span class="math inline">\(Pr[Privk^{eav}_{A,\pi}=1]=\frac{1}{2}+\epsilon(n)\leq
\frac{1}{2} + negl(n)\)</span></p>
<h3 id="流密码">流密码</h3>
<p>流密码是一种确定性的算法，分为两步：</p>
<p>初始化Init：输入一个随机种子s和一个可选的初始化向量IV，输出一个初始化状态<span class="math inline">\(St_0\)</span></p>
<p>获取密码Getbits：输入前一个状态<span class="math inline">\(St_{i-1}\)</span>,输出当前状态<span class="math inline">\(St_t\)</span>和获取到的密钥流<span class="math inline">\(y_i\)</span></p>
<p>优点：简单高效，可以加密任意长度的明文</p>
<p>缺点：不能用相同的密钥流加密明文，否则容易发现明文之间的相关性，容易受到字节翻转攻击</p>
<p><strong>同步模式:</strong>
双方使用密钥流的不同部分来加密每个信息。在这个模式下，双方必须同步通讯，来得知流的多少位已经被使用。这个算法虽然是确定性的，但在每一次加密过程中，密钥是互不重复的，因此对于每次加密来说，相同的明文也会被加密成不同的密文。</p>
<p><strong>非同步模式：</strong>
双方可以独立进行加密，无需维护状态。但是，这里需要 PRG
有两个输入：一个种子k以及一个初始向量IV. 如果两个初始向量不一样，那么
PRG 的生成结果也不一样。</p>
<p>在非同步模式下，加密方法为<span class="math inline">\(Enc_k(m)=&lt;IV,G(k,IV)\oplus m&gt;\)</span>
其中IV是随机选择的，与异或结果一同输出，攻击者能得到IV，但是由于没有种子k，所以依然没法解密。</p>
<h4 id="线性反馈移位寄存器lfsr">线性反馈移位寄存器（LFSR）</h4>
<p>一个n位的寄存器有n个寄存器<span class="math inline">\(s_{n-1}...s_{0}\)</span>和n个反馈常数<span class="math inline">\(c_{n-1}...c_0\)</span></p>
<p>当前状态即为n个寄存器里面值的集合，下一个状态为：
对于低n-1位，直接把上面一位向右移一位，对于最高位，是将原先所有的n位寄存器中的值和反馈常数相乘之后进行异或操作。</p>
<p>输出是字节序列<span class="math inline">\(s_0^{(0)},s_0^{(1)}...\)</span></p>
<p>缺点：一个n位的线性反馈移位寄存器，在最多<span class="math inline">\(2^n\)</span>次移位后就会重复原先的序列。由于线性，一个4位的寄存器在接受到前八位输出后就能破解刚开始的状态和反馈常数。</p>
<h4 id="增加非线性">增加非线性</h4>
<p>为了防止上面的破解方法，可以在GetBits函数中生成状态或者获得bit时引入非线性
<img src="/2024/09/20/Crypto/pic3.png"> 在私钥加密中，块密码比流密码更加安全</p>
<h3 id="cpa安全和伪随机函数">CPA安全和伪随机函数</h3>
<h4 id="多消息窃听者实验privkmult_apin">多消息窃听者实验：<span class="math inline">\(Privk^{mult}_{A,\Pi}(n)\)</span></h4>
<p>敌手A被给定一个输入<span class="math inline">\(1^n\)</span>,输出一对消息向量<span class="math inline">\(\vec{M}_0=(m_0^1...m_0^t)\)</span>以及<span class="math inline">\(\vec{M}_1=(m_1^1...m_1^t)\)</span></p>
<p>通过运行<span class="math inline">\(Gen(1^n)\)</span>生成一个密钥k和选择一个随机比特b，对所有i，计算密文<span class="math inline">\(c^i\gets Enc_k(m_b^i)\)</span>,并且把密文向量<span class="math inline">\(\vec{C}=(c^1...c^t)\)</span>给A</p>
<p>A输出一个比特b'进行比较。</p>
<h4 id="窃听者存在的情况下不可区分多次加密">窃听者存在的情况下不可区分多次加密</h4>
<p>一个对称密钥加密方案<span class="math inline">\(\Pi\)</span>,如果对所有的概率多项式时间敌手A，存在一个可忽略函数negl,满足
<span class="math inline">\(Pr[Privk^{mult}_{A,\Pi}=1]\leq
\frac{1}{2}+negl\)</span></p>
<p>则称其具有窃听者存在的情况下不可区分多次加密</p>
<h5 id="命题存在这样的对称加密方案满足窃听者存在情况下不可区分的加密但不满足窃听者存在情况下不可区分的多次加密">命题：存在这样的对称加密方案，满足窃听者存在情况下不可区分的加密，但不满足窃听者存在情况下不可区分的多次加密。</h5>
<p>需要概率加密。</p>
<h4 id="选择明文攻击cpa的安全性">选择明文攻击(CPA)的安全性</h4>
<p>CPA的想法是增强了敌手的能力，原先敌手只能被动的接受信息，现在敌手可以主动的访问加密机。</p>
<p>CPA不可区分实验<span class="math inline">\(Privk^{CPA}_{A,\Pi}(n)\)</span>,敌手可以要求语言机加密消息<span class="math inline">\(m_0、m_1\)</span>,从而获得<span class="math inline">\(c_0 \gets Enc_k(m_0)\)</span>和<span class="math inline">\(c_1 \gets Enc_k(m_1)\)</span></p>
<p>必须要把随机性作为加密过程的一部分，确保相同消息加密后密文是不同的。</p>
<h4 id="伪随机函数">伪随机函数</h4>
<p>如果一个函数<span class="math inline">\(F_k\)</span>(对于一个均匀随机密钥k)，与一个均匀随机函数是不可区分的，那么我们称这个函数是伪随机函数。</p>
<p>正式定义：对于一个长度保持的密钥函数<span class="math inline">\(F:(0,1)^{l_{key}(n)}\times(0,1)^{l_{in}(n)}\to
(0,1)^{l_{out}(n)},l_{key}(n)=l_{in}(n)=l_{out}(n)=n\)</span>,f是一个均匀随机函数，F是一个伪随机函数如果对于所有的PPT
区分器D，都有一个可忽略函数negl使得 <span class="math display">\[|Pr[D^{F_k(\cdot)}(1^n)=1]-Pr[D^{f(\cdot)}(1^n)=1]|\leq
negl(n)\]</span></p>
<p>随机函数接受两个输入，一个是密钥k，另一个是输入x，对于n位长的真随机函数，其规模是<span class="math inline">\(2^{n2^n}\)</span>,而对于密钥长度为n的伪随机函数，其规模是<span class="math inline">\(2^n\)</span>.如果</p>
<h4 id="基于伪随机函数构造cpa安全加密">基于伪随机函数构造CPA安全加密</h4>
<p>令F是伪随机函数，定义一个消息长度为n的对称密钥加密方案如下：</p>
<p>Gen：输入<span class="math inline">\(1^n\)</span>,均匀随机选择<span class="math inline">\(k \gets
\{0,1\}^n\)</span>,并将其作为密钥输出。</p>
<p>Enc:输入密钥k，以及一个消息<span class="math inline">\(m\in
\{0,1\}^n\)</span>,均匀随机选择随机数<span class="math inline">\(r\gets\{0,1\}^n\)</span>,输出密文 <span class="math inline">\(c:=&lt;r,F_k(r)\oplus m&gt;\)</span></p>
<p>Dec:输入一个密钥<span class="math inline">\(k\in
\{0,1\}^n\)</span>,以及一个密文c=&lt;r,s&gt;,输出明文消息 <span class="math inline">\(m:=F_k(r)\oplus s\)</span></p>
<h4 id="如果f是伪随机函数则构造方案如上的消息长度为n的定长对称密钥加密方案在cpa下具备不可区分加密">如果F是伪随机函数，则构造方案如上的消息长度为n的定长对称密钥加密方案在CPA下具备不可区分加密。</h4>
<p>令<span class="math inline">\(\hat{\Pi}\)</span>为用真随机函数f取代Fk的构造方法。</p>
<p>敌手A对他的加密预言机问询q(n)次，有<span class="math inline">\(Pr[Privk^{cpa}_{A,\hat{\Pi}=1}]\leq
\frac{1}{2}+\frac{q(n)}{2^n}\)</span></p>
<p>同样构造区分器D</p>
<p>D被指定了输入<span class="math inline">\(1^n\)</span>以及可以访问预言机<span class="math inline">\(O:\{0,1\}^n \to \{0,1\}^n\)</span></p>
<p>运行A(1^n),用下面方式回答问询：</p>
<p>1.均匀随机选择<span class="math inline">\(r\gets \{0,1\}^n\)</span>
2.问询O(r),获得s'</p>
<p>3.返回密文<span class="math inline">\(&lt;r,s&#39;\oplus
m_b&gt;\)</span></p>
<p>当A输出两个消息m，随机选择一个比特b</p>
<p>1.均匀随机选择r</p>
<p>2.问询O(r),获得相应s'</p>
<p>3.返回挑战密文<span class="math inline">\(&lt;r,s&#39;\oplus
m_b&gt;\)</span></p>
<p>最后A输出一个b'</p>
<p>有<span class="math inline">\(Pr[D^{F_k(\cdot)}(1^n)=1]=Pr[Privk^{cpa}_{A,\Pi}(n)=1]=\frac{1}{2}+\epsilon(n)\)</span></p>
<p><span class="math inline">\(Pr[D^{f(\cdot)}(1^n)=1]=Pr[Privk^{cpa}_{A,\hat{\Pi}}(n)=1]=\frac{1}{2}+\frac{q(n)}{2^n}\)</span></p>
<p><span class="math inline">\(|Pr[D^{F_k(\cdot)}(1^n)=1]-Pr[D^{f(\cdot)}(1^n)=1]|=\epsilon(n)-\frac{q(n)}{2^n}\)</span>
证毕</p>
<h4 id="任意cpa安全的加密方案对多次加密也是安全的">任意CPA安全的加密方案对多次加密也是安全的</h4>
<h4 id="排序和伪随机排序">排序和伪随机排序</h4>
<p>设<span class="math inline">\(Perm_n\)</span>是<span class="math inline">\(\{0,1\}^n\)</span>所有排列的集合，则<span class="math inline">\(Perm_n\)</span>的规模是<span class="math inline">\((2^n)!\)</span></p>
<p>一个伪随机排列就是输入一个k和x，输出y，并且没有一个有效的方法来区分这个排列和随机选择的函数，则称这个排列是一个伪随机排列。因为这两者看上去是相同的，除非能找到一对不同的值x和y，使得f(x)=f(y)</p>
<p>当一个伪随机排列的长度足够长，那么他和一个伪随机函数是不可区分的，即如果F是一个伪随机排列。且<span class="math inline">\(I_{in}&gt;n\)</span>,那么F也是一个伪随机函数。</p>
<h4 id="强伪随机排列">强伪随机排列</h4>
<p>如果给区分器使用逆排序预言机的能力，其依然无法区分<span class="math inline">\(F_k\)</span>和一个随机置换，则称F是强伪随机置换。</p>
<p><span class="math inline">\(F:\{0,1\}^*\times \{0,1\}^*\to
\{0,1\}^*\)</span>是一个有效的带密钥的置换，如果对于所有多项式时间区分器D，存在一个可忽略函数negl,使得
<span class="math display">\[|Pr[D^{F_k(\cdot)F_k^{-1}(\cdot)(1^n)}=1]-Pr[D^{f(\cdot)f^{-1}(\cdot)(1^n)}=1]|\leq
negl(n)\]</span> 则称F是强伪随机置换</p>
<h4 id="prfs-and-prgs相互构造">PRFs and PRGs相互构造</h4>
<h3 id="分组密码block-cipher">分组密码Block Cipher</h3>
<p>分组密码是一个高效的、含k输入的排列函数</p>
<p><span class="math inline">\(F:\{0,1\}^n\times \{0,1\}^l\to
\{0,1\}^l\)</span></p>
<p>F就是一个含k的排列函数，高效体现在给定k，可以很快计算出<span class="math inline">\(F_k(x)\)</span>和他的逆<span class="math inline">\(F_k^{-1}(x)\)</span>,n是键长，l是块长</p>
<p>无论是分组密码还是流密码，其本身都不是一个加密的方式，其提供了一种操作模式</p>
<p>分组密码+操作方式=长信息加密方式</p>
<p>常见的操作方式有：</p>
<p>电子代码簿Electronic Code Book（ECB）模式；</p>
<p>密码块链接Cipher Block Chaining（CBC）模式；</p>
<p>输出反馈Output Feedback（OFB）模式；</p>
<p>计数器Counter（CTR）模式。</p>
<p>让m代表明文，<span class="math inline">\(m_1,m_2...m_l\)</span>代表明文块</p>
<h5 id="ecb模式">ECB模式</h5>
<p>ECB模式很简单，就是<span class="math inline">\(c:=&lt;F_k(m_1),F_k(m_2)...F_k(m_l
)&gt;\)</span></p>
<p>安全性：由于是确定性算法，所以不是CPA安全的，不安全，永远不应该被应用。</p>
<h5 id="cbc模式">CBC模式</h5>
<p>第一段密文<span class="math inline">\(c_0\)</span>赋值为一个随机数IV，然后逐个生成后面的密文：</p>
<p><span class="math inline">\(c_i:=F_k(c_{i-1}\oplus m_i)\)</span> for
i=1...l</p>
<p>生成密文<span class="math inline">\(&lt;c_0,c_1...c_l&gt;\)</span></p>
<p>解密要用<span class="math inline">\(F_k^{-1}\)</span></p>
<p><span class="math inline">\(m_i:=F_k^{-1}(c_i)\oplus
c_{i-1}\)</span></p>
<p>分析：这个加密是概率性的，如果F是一个伪随机函数，那么CBC是CPA安全的，缺点是加密过程不能并行进行。</p>
<h5 id="ofb模式">OFB模式</h5>
<p>加密时生成一个随机串IV，为加密的每个块生成一个随机密码</p>
<p><span class="math inline">\(y_0:=IV,y_i=F_k(y_{i-1})\)</span>,然后与明文块进行异或操作：<span class="math inline">\(c_i=m_i\oplus y_i\)</span></p>
<p>密文是<span class="math inline">\(&lt;IV,c_1,c_2...c_l&gt;\)</span></p>
<p>分析：<span class="math inline">\(F_k\)</span>不需要逆运算，如果F是伪随机函数，那么OFB模式是CPA安全的，同时支持预先操作，把要用的随机密码提前生成出来</p>
<h5 id="ctr模式">CTR模式</h5>
<p>在加密时生成一个随机数ctr，以如下方式为每一个块产生随机密码：</p>
<p><span class="math inline">\(y_i=F_k(ctr+i),c_i=y_i\oplus
m_i\)</span>,生成的密文是<span class="math inline">\(&lt;ctr,c_1,...c_l&gt;\)</span></p>
<p>分析：如果F是伪随机函数，那么是CPA的，并且支持并行计算。</p>
<h4 id="设计分组密码">设计分组密码</h4>
<h5 id="the-avalanche-effect一个好的分组密码应该有雪崩效应">The
avalanche effect一个好的分组密码应该有雪崩效应</h5>
<p>输入改变一点点必须要影响输出的每一位</p>
<h5 id="spn-substitution-permutation-networks替换排列网络">SPN:
Substitution-Permutation Networks替换排列网络</h5>
<p>SPN满足confusion-diffusion paradigm(混淆扩散范式)</p>
<p>重复多次混淆步骤和扩散步骤：</p>
<p>分组密码的输入被分成了若干小块，每一轮，先把每一个小块输入到一个随机排列中，再使用一个混合排列把所有小块混合到一起</p>
<p>SPN是基于上面范式的变体来运行的：</p>
<p>1.key mixing：在每一回合中，先将输入和子密钥(sub-key or
round-key)进行异或操作</p>
<p>2.substitution:在进行key
mixing后，每一个子块i被输入到一个固定的，可逆的替换函数<span class="math inline">\(S_i\)</span>(S盒)中</p>
<p>3.Permutation：S盒的所有输出进行排列</p>
<p>替换步骤和排列步骤的细节都是公开的，任何攻击者都可以知道。只有钥匙被保密。（这种设置被称为克霍夫原理）</p>
<p>输出是最后一次进行key
mixing后的结果，即先进行上面三步r次，最后再进行一次key mixing。</p>
<h5 id="feistel-network">Feistel network</h5>
<p>与SPN的区别是不需要函数可逆</p>
<p>第i次round function <span class="math inline">\(\hat{f_i}\)</span>有两个输入，一个是子密钥<span class="math inline">\(k_i\)</span>，另一个是一个<span class="math inline">\(\frac{l}{2}\)</span>长的字串，输出一个同样长度的字串。定义<span class="math inline">\(f_i(R)=\hat{f_i(k_i,R)}\)</span></p>
<p>加密流程：</p>
<p><span class="math inline">\(L_i=R_{i-1}\)</span></p>
<p><span class="math inline">\(R_i=L_{i-1}\oplus
f_i(R_{i-1})\)</span></p>
<p>解密流程：</p>
<p><span class="math inline">\(R_{i-1}=L_i\)</span></p>
<p><span class="math inline">\(L_{i-1}=R_i\oplus
f_i(R_{i-1})\)</span></p>
<p><span class="math inline">\(\hat{f_i}\)</span>是固定的，并且是公开的，但是<span class="math inline">\(f_i\)</span>不是。</p>
<p><img src="/2024/09/20/Crypto/pic4.png"></p>
<h4 id="分组密码样例">分组密码样例</h4>
<h5 id="des">DES</h5>
<p><img src="/2024/09/20/Crypto/pic5.png"> 缺点：key太短</p>
<h5 id="des-1">3DES</h5>
<p>实现112位安全，但是现在推荐最短长度为128，所以推荐用AES替代</p>
<p><img src="/2024/09/20/Crypto/pic6.png"></p>
<h5 id="aes">AES</h5>
<p>128-bit block length.</p>
<p>supports 128-bit (10 rounds), 192-bit (12 rounds), 256-bit(14
rounds)keys.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2024/09/20/Crypto/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/09/18/updating_in_9-18-2024/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">updating in 9-18-2024</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2024
        <i class="ri-heart-fill heart_icon"></i> MorningStar
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="GaoGe&#39;s Homepage"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat1.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>