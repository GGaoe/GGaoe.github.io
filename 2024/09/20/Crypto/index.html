<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="Learning,Life,高歌,Gaoge" />
       
      <meta name="description" content="be yourself" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Crypto笔记 |  GaoGe&#39;s Homepage</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Crypto"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Crypto笔记
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/09/20/Crypto/" class="article-date">
  <time datetime="2024-09-20T03:40:37.136Z" itemprop="datePublished">2024-09-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Learning/">Learning</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">13.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">52 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="introduction">Introduction</h3>
<p>凯撒移位密码：key space太小</p>
<p>单字母替代密码：一个字母的加密方式总是一样的，统计攻击破解，如果我们知道一个字母在明文中出现的频率，就可以极大缩小明文的搜索空间</p>
<p>替代方法：多字母替换</p>
<p>維吉尼亞密碼 or 多字母移位密碼：是多密码替换的特殊情况
破解方式：先确定加密密钥的长度m，然后break出m个加密密钥（统计攻击破解）</p>
<h3 id="perfect-secrecy完美保密性">Perfect Secrecy（完美保密性）</h3>
<h4 id="defining-an-encryption-scheme">Defining an encryption
scheme</h4>
<p><img src="/2024/09/20/Crypto/pic1.png"></p>
<p>密文空间 M 上的一个加密算法 (Gen, Enc, Dec) 是完美保密的，如果对于 M
上的每个分布都有 <span class="math inline">\(Pr[M=m|C=c]=Pr[M=m]\)</span>，对于每个 <span class="math inline">\(m \in M\)</span> 和每个 <span class="math inline">\(c \in C\)</span>，且 <span class="math inline">\(Pr[C = c] &gt; 0\)</span>。</p>
<p>可以用贝叶斯公式等完成证明；</p>
<p>完美保密性含义：不会因为知道密文而获取到明文的任何信息。</p>
<h4 id="一个等效的完美保密性的定义">一个等效的完美保密性的定义:</h4>
<p>一种加密方案 (Gen, Enc, Dec) 在消息空间 M
上是完全保密的，当且仅当对于每个 m, m′ ∈ M 和每个 c ∈ C：<span class="math inline">\(Pr[C = c|M = m] = Pr[C = c|M = m′]\)</span></p>
<p>密文的分布相对于明文是独立的</p>
<h4 id="完美不可分辨性">完美不可分辨性：</h4>
<p>A向B发送两组明文<span class="math inline">\(m_1,m_2\)</span>,B通过Gen获取一个密钥k，并均匀随机的抽取明文中的其中一个n进行加密，将加密后的密文传给A。通过获取到的密文c，A猜测n是第一位还是第二位。如果猜对了，则<span class="math inline">\(PrivK^{eav}_{A,\Pi}=1\)</span> <img src="/2024/09/20/Crypto/pic2.png"> 有完美保密性当且仅当有完美不可分辨性</p>
<h4 id="一次一密">一次一密：</h4>
<p>只有密码只使用一次和只知密文时有保密性</p>
<h4 id="完美保密性的限制">完美保密性的限制：</h4>
<p>必须要求|K|&gt;=|M|</p>
<h4 id="香农定理">香农定理：</h4>
<p>一个加密算法，有|M|=|K|=|C|,当且仅当满足下列性质时，算法是完美保密的：
Gen选取密钥是对于每一个密钥k，都以相同的概率<span class="math inline">\(\frac{1}{|K|}\)</span>获取
对于每一个明文m和密文c，存在一个唯一的密钥k，使得<span class="math inline">\(Enc_k(m)\)</span> 输出c</p>
<h3 id="计算安全理论">计算安全理论</h3>
<p>计算安全性的渐进方法 有效的对手 = 随机算法 + 多项式时间 有界 =
概率多项式时间Probabilistic Polynomial-Time（有界）算法= PPT 算法</p>
<p>一个从自然数到非负实数的函数 negl(·)
是可忽略的，如果对于每一个正多项式 p，都存在一个 N，使得对于所有整数
<span class="math inline">\(n &gt; N，negl(n) &lt; 1/p(n)\)</span>。
一个从自然数到非负实数的函数 negl(·) 是可忽略的，如果对于每一个正整数
c，都存在一个 <span class="math inline">\(N_c\)</span>，使得对于所有整数
<span class="math inline">\(n &gt; N_c，negl(n) &lt;
1/n^c\)</span>。</p>
<p>设<span class="math inline">\(negl_1\)</span> 和 <span class="math inline">\(negl_2\)</span>是可忽略函数。那么， 1.
如果存在一个整数 <span class="math inline">\(N_c\)</span> 使得对于所有
<span class="math inline">\(n ≥ N_c，f(n) &lt; negl_1(n)\)</span>
成立，则 f(n) 是可忽略的。</p>
<ol start="2" type="1">
<li><p>函数 <span class="math inline">\(negl_3(n) = negl_1(n) +
negl_2(n)\)</span> 也是可忽略的。</p></li>
<li><p>对于任何正多项式 p，定义函数 <span class="math inline">\(negl_4\)</span> 为 <span class="math inline">\(negl4(n) = p(n) · negl_1(n)\)</span>，则 <span class="math inline">\(negl_4\)</span> 也是可忽略的。</p></li>
</ol>
<h5 id="常见的可忽略函数">常见的可忽略函数</h5>
<p><span class="math inline">\(2^{-n},2^{-\sqrt{n}},n^{-logn}\)</span>都是可以忽略的</p>
<p>一个方案是安全的，如果对于每一个多项式时间有界对手 A
进行某种形式上指定类型的攻击，A 成功攻击的概率是可忽略的。</p>
<p>等价定义：一个方案是安全的，如果对于每一个多项式时间有界对手 A
进行某种形式上指定类型的攻击，并且对于每一个正多项式 p，存在一个整数
N，使得当 n &gt; N 时，A 成功攻击的概率小于 <span class="math inline">\(\frac{1}{p(n)}\)</span>。</p>
<h4 id="indistinguishable-encryptions-in-the-presence-of-an-eavesdropper-or-eav-secure">indistinguishable
encryptions in the presence of an eavesdropper or EAV-secure</h4>
<p>对于任意n，存在一个可以忽略的函数negl，使得 <span class="math display">\[Pr[PrivK^{env}_{A,\Pi}=1]\leq
\frac{1}{2}+negl(n)\]</span> 一个等效的定义： <span class="math display">\[Pr[out_A(PrivK^{env}_{A,\Pi}(n,0))=1]-Pr[out_A(PrivK^{env}_{A,\Pi}(n,1))=1]\leq
negl(n)\]</span> 其中<span class="math inline">\(PrivK^{env}_{A,\Pi}(n,b)\)</span>表示在不可区分性实验中使用一个固定的b，并且out代表A的输出。</p>
<h3 id="构建在计算上安全的加密">构建在计算上安全的加密</h3>
<h4 id="伪随机数发生器">伪随机数发生器</h4>
<p>令l(·)是一个多项式，令G是一个确定多项式时间算法，该算法满足：对于任意输入<span class="math inline">\(s=\{0,1\}^n\)</span>,算法输出一个长度为l(n)的字符串，如果满足下列两个条件，则称G是一个伪随机发生器：</p>
<p>1.扩展性：对于每个n来说，l(n)&gt;n</p>
<p>2.伪随机性：对于所有的概率随机性多项式时间的区分器D来说，存在一个可忽略函数negl，满足
<span class="math display">\[|Pr[D(r)=1]-Pr[D(G(s))=1]|\leq
negl(n)\]</span> 其中r是从<span class="math inline">\(\{0,1\}^l(n)\)</span>中均匀随机选择的，种子s是从<span class="math inline">\(\{0,1\}^n\)</span>中选择的。</p>
<h4 id="用伪随机数发生器构造的一次一密是eav安全的">用伪随机数发生器构造的一次一密是EAV安全的</h4>
<p>证明方法是用规约，已知伪随机数发生器和真随机之间是eav安全的，无法用PPT算法来分辨，那么：</p>
<p>假设构造的一次一密<span class="math inline">\(Pr[Privk^{eav}_{A,\pi}=1]=\frac{1}{2}+\epsilon(n)\)</span></p>
<p>我们要证<span class="math inline">\(\epsilon(n)\leq
negl(n)\)</span>,否则存在一个算法可以区分伪随机数和真随机</p>
<p>于是通过这两种一次一密构建了一个区分器D</p>
<p>当w=r时，<span class="math inline">\(Pr[D[w]=1]=Pr[D[r]]=Pr[Privk^{eav}_{A,\hat{\pi}}=1]=\frac{1}{2}\)</span></p>
<p>当w=G(n)时，<span class="math inline">\(Pr[D[w]=1]=Pr[D[G[n]]=1]=Pr[Privk^{eav}_{A,\pi}=1]=\frac{1}{2}+\epsilon(n)\)</span></p>
<p>其中第二个等号成立，是由于D就是由A构造出来的函数，通过A的输出来充当D的输出，所以两个函数的输出其实是相同的。</p>
<p>所以<span class="math inline">\(|Pr[D[r]]-Pr[D[G[n]]]|=\epsilon(n)\)</span></p>
<p>由伪随机数发生器的定义，<span class="math inline">\(\epsilon(n)\leq
negl(n)\)</span></p>
<p>所以构造出来的一次一密<span class="math inline">\(Pr[Privk^{eav}_{A,\pi}=1]=\frac{1}{2}+\epsilon(n)\leq
\frac{1}{2} + negl(n)\)</span></p>
<h3 id="流密码">流密码</h3>
<p>流密码是一种确定性的算法，分为两步：</p>
<p>初始化Init：输入一个随机种子s和一个可选的初始化向量IV，输出一个初始化状态<span class="math inline">\(St_0\)</span></p>
<p>获取密码Getbits：输入前一个状态<span class="math inline">\(St_{i-1}\)</span>,输出当前状态<span class="math inline">\(St_t\)</span>和获取到的密钥流<span class="math inline">\(y_i\)</span></p>
<p>优点：简单高效，可以加密任意长度的明文</p>
<p>缺点：不能用相同的密钥流加密明文，否则容易发现明文之间的相关性，容易受到字节翻转攻击</p>
<p><strong>同步模式:</strong>
双方使用密钥流的不同部分来加密每个信息。在这个模式下，双方必须同步通讯，来得知流的多少位已经被使用。这个算法虽然是确定性的，但在每一次加密过程中，密钥是互不重复的，因此对于每次加密来说，相同的明文也会被加密成不同的密文。</p>
<p><strong>非同步模式：</strong>
双方可以独立进行加密，无需维护状态。但是，这里需要 PRG
有两个输入：一个种子k以及一个初始向量IV. 如果两个初始向量不一样，那么
PRG 的生成结果也不一样。</p>
<p>在非同步模式下，加密方法为<span class="math inline">\(Enc_k(m)=&lt;IV,G(k,IV)\oplus m&gt;\)</span>
其中IV是随机选择的，与异或结果一同输出，攻击者能得到IV，但是由于没有种子k，所以依然没法解密。</p>
<h4 id="线性反馈移位寄存器lfsr">线性反馈移位寄存器（LFSR）</h4>
<p>一个n位的寄存器有n个寄存器<span class="math inline">\(s_{n-1}...s_{0}\)</span>和n个反馈常数<span class="math inline">\(c_{n-1}...c_0\)</span></p>
<p>当前状态即为n个寄存器里面值的集合，下一个状态为：
对于低n-1位，直接把上面一位向右移一位，对于最高位，是将原先所有的n位寄存器中的值和反馈常数相乘之后进行异或操作。</p>
<p>输出是字节序列<span class="math inline">\(s_0^{(0)},s_0^{(1)}...\)</span></p>
<p>缺点：一个n位的线性反馈移位寄存器，在最多<span class="math inline">\(2^n\)</span>次移位后就会重复原先的序列。由于线性，一个4位的寄存器在接受到前八位输出后就能破解刚开始的状态和反馈常数。</p>
<h4 id="增加非线性">增加非线性</h4>
<p>为了防止上面的破解方法，可以在GetBits函数中生成状态或者获得bit时引入非线性
<img src="/2024/09/20/Crypto/pic3.png"> 在私钥加密中，块密码比流密码更加安全</p>
<h3 id="cpa安全和伪随机函数">CPA安全和伪随机函数</h3>
<h4 id="多消息窃听者实验privkmult_apin">多消息窃听者实验：<span class="math inline">\(Privk^{mult}_{A,\Pi}(n)\)</span></h4>
<p>敌手A被给定一个输入<span class="math inline">\(1^n\)</span>,输出一对消息向量<span class="math inline">\(\vec{M}_0=(m_0^1...m_0^t)\)</span>以及<span class="math inline">\(\vec{M}_1=(m_1^1...m_1^t)\)</span></p>
<p>通过运行<span class="math inline">\(Gen(1^n)\)</span>生成一个密钥k和选择一个随机比特b，对所有i，计算密文<span class="math inline">\(c^i\gets Enc_k(m_b^i)\)</span>,并且把密文向量<span class="math inline">\(\vec{C}=(c^1...c^t)\)</span>给A</p>
<p>A输出一个比特b'进行比较。</p>
<h4 id="窃听者存在的情况下不可区分多次加密">窃听者存在的情况下不可区分多次加密</h4>
<p>一个对称密钥加密方案<span class="math inline">\(\Pi\)</span>,如果对所有的概率多项式时间敌手A，存在一个可忽略函数negl,满足
<span class="math inline">\(Pr[Privk^{mult}_{A,\Pi}=1]\leq
\frac{1}{2}+negl\)</span></p>
<p>则称其具有窃听者存在的情况下不可区分多次加密</p>
<h5 id="命题存在这样的对称加密方案满足窃听者存在情况下不可区分的加密但不满足窃听者存在情况下不可区分的多次加密">命题：存在这样的对称加密方案，满足窃听者存在情况下不可区分的加密，但不满足窃听者存在情况下不可区分的多次加密。</h5>
<p>需要概率加密。</p>
<h4 id="选择明文攻击cpa的安全性">选择明文攻击(CPA)的安全性</h4>
<p>CPA的想法是增强了敌手的能力，原先敌手只能被动的接受信息，现在敌手可以主动的访问加密机。</p>
<p>CPA不可区分实验<span class="math inline">\(Privk^{CPA}_{A,\Pi}(n)\)</span>,敌手可以要求语言机加密消息<span class="math inline">\(m_0、m_1\)</span>,从而获得<span class="math inline">\(c_0 \gets Enc_k(m_0)\)</span>和<span class="math inline">\(c_1 \gets Enc_k(m_1)\)</span></p>
<p>必须要把随机性作为加密过程的一部分，确保相同消息加密后密文是不同的。</p>
<h4 id="伪随机函数">伪随机函数</h4>
<p>如果一个函数<span class="math inline">\(F_k\)</span>(对于一个均匀随机密钥k)，与一个均匀随机函数是不可区分的，那么我们称这个函数是伪随机函数。</p>
<p>正式定义：对于一个长度保持的密钥函数<span class="math inline">\(F:(0,1)^{l_{key}(n)}\times(0,1)^{l_{in}(n)}\to
(0,1)^{l_{out}(n)},l_{key}(n)=l_{in}(n)=l_{out}(n)=n\)</span>,f是一个均匀随机函数，F是一个伪随机函数如果对于所有的PPT
区分器D，都有一个可忽略函数negl使得 <span class="math display">\[|Pr[D^{F_k(\cdot)}(1^n)=1]-Pr[D^{f(\cdot)}(1^n)=1]|\leq
negl(n)\]</span></p>
<p>随机函数接受两个输入，一个是密钥k，另一个是输入x，对于n位长的真随机函数，其规模是<span class="math inline">\(2^{n2^n}\)</span>,而对于密钥长度为n的伪随机函数，其规模是<span class="math inline">\(2^n\)</span>.如果</p>
<h4 id="基于伪随机函数构造cpa安全加密">基于伪随机函数构造CPA安全加密</h4>
<p>令F是伪随机函数，定义一个消息长度为n的对称密钥加密方案如下：</p>
<p>Gen：输入<span class="math inline">\(1^n\)</span>,均匀随机选择<span class="math inline">\(k \gets
\{0,1\}^n\)</span>,并将其作为密钥输出。</p>
<p>Enc:输入密钥k，以及一个消息<span class="math inline">\(m\in
\{0,1\}^n\)</span>,均匀随机选择随机数<span class="math inline">\(r\gets\{0,1\}^n\)</span>,输出密文 <span class="math inline">\(c:=&lt;r,F_k(r)\oplus m&gt;\)</span></p>
<p>Dec:输入一个密钥<span class="math inline">\(k\in
\{0,1\}^n\)</span>,以及一个密文c=&lt;r,s&gt;,输出明文消息 <span class="math inline">\(m:=F_k(r)\oplus s\)</span></p>
<h4 id="如果f是伪随机函数则构造方案如上的消息长度为n的定长对称密钥加密方案在cpa下具备不可区分加密">如果F是伪随机函数，则构造方案如上的消息长度为n的定长对称密钥加密方案在CPA下具备不可区分加密。</h4>
<p>令<span class="math inline">\(\hat{\Pi}\)</span>为用真随机函数f取代Fk的构造方法。</p>
<p>敌手A对他的加密预言机问询q(n)次，有<span class="math inline">\(Pr[Privk^{cpa}_{A,\hat{\Pi}=1}]\leq
\frac{1}{2}+\frac{q(n)}{2^n}\)</span></p>
<p>同样构造区分器D</p>
<p>D被指定了输入<span class="math inline">\(1^n\)</span>以及可以访问预言机<span class="math inline">\(O:\{0,1\}^n \to \{0,1\}^n\)</span></p>
<p>运行A(1^n),用下面方式回答问询：</p>
<p>1.均匀随机选择<span class="math inline">\(r\gets \{0,1\}^n\)</span>
2.问询O(r),获得s'</p>
<p>3.返回密文<span class="math inline">\(&lt;r,s&#39;\oplus
m_b&gt;\)</span></p>
<p>当A输出两个消息m，随机选择一个比特b</p>
<p>1.均匀随机选择r</p>
<p>2.问询O(r),获得相应s'</p>
<p>3.返回挑战密文<span class="math inline">\(&lt;r,s&#39;\oplus
m_b&gt;\)</span></p>
<p>最后A输出一个b'</p>
<p>有<span class="math inline">\(Pr[D^{F_k(\cdot)}(1^n)=1]=Pr[Privk^{cpa}_{A,\Pi}(n)=1]=\frac{1}{2}+\epsilon(n)\)</span></p>
<p><span class="math inline">\(Pr[D^{f(\cdot)}(1^n)=1]=Pr[Privk^{cpa}_{A,\hat{\Pi}}(n)=1]=\frac{1}{2}+\frac{q(n)}{2^n}\)</span></p>
<p><span class="math inline">\(|Pr[D^{F_k(\cdot)}(1^n)=1]-Pr[D^{f(\cdot)}(1^n)=1]|=\epsilon(n)-\frac{q(n)}{2^n}\)</span>
证毕</p>
<h4 id="任意cpa安全的加密方案对多次加密也是安全的">任意CPA安全的加密方案对多次加密也是安全的</h4>
<h4 id="排序和伪随机排序">排序和伪随机排序</h4>
<p>设<span class="math inline">\(Perm_n\)</span>是<span class="math inline">\(\{0,1\}^n\)</span>所有排列的集合，则<span class="math inline">\(Perm_n\)</span>的规模是<span class="math inline">\((2^n)!\)</span></p>
<p>一个伪随机排列就是输入一个k和x，输出y，并且没有一个有效的方法来区分这个排列和随机选择的函数，则称这个排列是一个伪随机排列。因为这两者看上去是相同的，除非能找到一对不同的值x和y，使得f(x)=f(y)</p>
<p>当一个伪随机排列的长度足够长，那么他和一个伪随机函数是不可区分的，即如果F是一个伪随机排列。且<span class="math inline">\(I_{in}&gt;n\)</span>,那么F也是一个伪随机函数。</p>
<h4 id="强伪随机排列">强伪随机排列</h4>
<p>如果给区分器使用逆排序预言机的能力，其依然无法区分<span class="math inline">\(F_k\)</span>和一个随机置换，则称F是强伪随机置换。</p>
<p><span class="math inline">\(F:\{0,1\}^*\times \{0,1\}^*\to
\{0,1\}^*\)</span>是一个有效的带密钥的置换，如果对于所有多项式时间区分器D，存在一个可忽略函数negl,使得
<span class="math display">\[|Pr[D^{F_k(\cdot)F_k^{-1}(\cdot)(1^n)}=1]-Pr[D^{f(\cdot)f^{-1}(\cdot)(1^n)}=1]|\leq
negl(n)\]</span> 则称F是强伪随机置换</p>
<h4 id="prfs-and-prgs相互构造">PRFs and PRGs相互构造</h4>
<h3 id="分组密码block-cipher">分组密码Block Cipher</h3>
<p>分组密码是一个高效的、含k输入的排列函数</p>
<p><span class="math inline">\(F:\{0,1\}^n\times \{0,1\}^l\to
\{0,1\}^l\)</span></p>
<p>F就是一个含k的排列函数，高效体现在给定k，可以很快计算出<span class="math inline">\(F_k(x)\)</span>和他的逆<span class="math inline">\(F_k^{-1}(x)\)</span>,n是键长，l是块长</p>
<p>无论是分组密码还是流密码，其本身都不是一个加密的方式，其提供了一种操作模式</p>
<p>分组密码+操作方式=长信息加密方式</p>
<p>常见的操作方式有：</p>
<p>电子代码簿Electronic Code Book（ECB）模式；</p>
<p>密码块链接Cipher Block Chaining（CBC）模式；</p>
<p>输出反馈Output Feedback（OFB）模式；</p>
<p>计数器Counter（CTR）模式。</p>
<p>让m代表明文，<span class="math inline">\(m_1,m_2...m_l\)</span>代表明文块</p>
<h5 id="ecb模式">ECB模式</h5>
<p>ECB模式很简单，就是<span class="math inline">\(c:=&lt;F_k(m_1),F_k(m_2)...F_k(m_l
)&gt;\)</span></p>
<p>安全性：由于是确定性算法，所以不是CPA安全的，不安全，永远不应该被应用。</p>
<h5 id="cbc模式">CBC模式</h5>
<p>第一段密文<span class="math inline">\(c_0\)</span>赋值为一个随机数IV，然后逐个生成后面的密文：</p>
<p><span class="math inline">\(c_i:=F_k(c_{i-1}\oplus m_i)\)</span> for
i=1...l</p>
<p>生成密文<span class="math inline">\(&lt;c_0,c_1...c_l&gt;\)</span></p>
<p>解密要用<span class="math inline">\(F_k^{-1}\)</span></p>
<p><span class="math inline">\(m_i:=F_k^{-1}(c_i)\oplus
c_{i-1}\)</span></p>
<p>分析：这个加密是概率性的，如果F是一个伪随机函数，那么CBC是CPA安全的，缺点是加密过程不能并行进行。</p>
<h5 id="ofb模式">OFB模式</h5>
<p>加密时生成一个随机串IV，为加密的每个块生成一个随机密码</p>
<p><span class="math inline">\(y_0:=IV,y_i=F_k(y_{i-1})\)</span>,然后与明文块进行异或操作：<span class="math inline">\(c_i=m_i\oplus y_i\)</span></p>
<p>密文是<span class="math inline">\(&lt;IV,c_1,c_2...c_l&gt;\)</span></p>
<p>分析：<span class="math inline">\(F_k\)</span>不需要逆运算，如果F是伪随机函数，那么OFB模式是CPA安全的，同时支持预先操作，把要用的随机密码提前生成出来</p>
<h5 id="ctr模式">CTR模式</h5>
<p>在加密时生成一个随机数ctr，以如下方式为每一个块产生随机密码：</p>
<p><span class="math inline">\(y_i=F_k(ctr+i),c_i=y_i\oplus
m_i\)</span>,生成的密文是<span class="math inline">\(&lt;ctr,c_1,...c_l&gt;\)</span></p>
<p>分析：如果F是伪随机函数，那么是CPA的，并且支持并行计算。</p>
<h4 id="设计分组密码">设计分组密码</h4>
<h5 id="the-avalanche-effect一个好的分组密码应该有雪崩效应">The
avalanche effect一个好的分组密码应该有雪崩效应</h5>
<p>输入改变一点点必须要影响输出的每一位</p>
<h5 id="spn-substitution-permutation-networks替换排列网络">SPN:
Substitution-Permutation Networks替换排列网络</h5>
<p>SPN满足confusion-diffusion paradigm(混淆扩散范式)</p>
<p>重复多次混淆步骤和扩散步骤：</p>
<p>分组密码的输入被分成了若干小块，每一轮，先把每一个小块输入到一个随机排列中，再使用一个混合排列把所有小块混合到一起</p>
<p>SPN是基于上面范式的变体来运行的：</p>
<p>1.key mixing：在每一回合中，先将输入和子密钥(sub-key or
round-key)进行异或操作</p>
<p>2.substitution:在进行key
mixing后，每一个子块i被输入到一个固定的，可逆的替换函数<span class="math inline">\(S_i\)</span>(S盒)中</p>
<p>3.Permutation：S盒的所有输出进行排列</p>
<p>替换步骤和排列步骤的细节都是公开的，任何攻击者都可以知道。只有钥匙被保密。（这种设置被称为克霍夫原理）</p>
<p>输出是最后一次进行key
mixing后的结果，即先进行上面三步r次，最后再进行一次key mixing。</p>
<h5 id="feistel-network">Feistel network</h5>
<p>与SPN的区别是不需要函数可逆</p>
<p>第i次round function <span class="math inline">\(\hat{f_i}\)</span>有两个输入，一个是子密钥<span class="math inline">\(k_i\)</span>，另一个是一个<span class="math inline">\(\frac{l}{2}\)</span>长的字串，输出一个同样长度的字串。定义<span class="math inline">\(f_i(R)=\hat{f_i(k_i,R)}\)</span></p>
<p>加密流程：</p>
<p><span class="math inline">\(L_i=R_{i-1}\)</span></p>
<p><span class="math inline">\(R_i=L_{i-1}\oplus
f_i(R_{i-1})\)</span></p>
<p>解密流程：</p>
<p><span class="math inline">\(R_{i-1}=L_i\)</span></p>
<p><span class="math inline">\(L_{i-1}=R_i\oplus
f_i(R_{i-1})\)</span></p>
<p><span class="math inline">\(\hat{f_i}\)</span>是固定的，并且是公开的，但是<span class="math inline">\(f_i\)</span>不是。</p>
<p><img src="/2024/09/20/Crypto/pic4.png"></p>
<h4 id="分组密码样例">分组密码样例</h4>
<h5 id="des">DES</h5>
<p><img src="/2024/09/20/Crypto/pic5.png"> 缺点：key太短</p>
<h5 id="des-1">3DES</h5>
<p>实现112位安全，但是现在推荐最短长度为128，所以推荐用AES替代</p>
<p><img src="/2024/09/20/Crypto/pic6.png"></p>
<h5 id="aes">AES</h5>
<p>128-bit block length.</p>
<p>supports 128-bit (10 rounds), 192-bit (12 rounds), 256-bit(14
rounds)keys.</p>
<h3 id="消息验证">消息验证</h3>
<p>加密无法完成消息认证的完整性测试</p>
<h4 id="消息鉴别码mac">消息鉴别码(MAC)</h4>
<p>消息鉴别码(MAC)是一个概率多项式时间算法三元组(Gen Mac Vrfy)满足：</p>
<p>Gen输入参数<span class="math inline">\(1^n\)</span>,输出密钥k，<span class="math inline">\(|k|\geq n\)</span></p>
<p>Mac输入k和消息m，输出t，算法是随机的，即<span class="math inline">\(t\gets Mac_k(m)\)</span></p>
<p>Vrfy输入密钥k，消息m和标记t，输出比特位b。<span class="math inline">\(b:=Vrfy_k(m,t)\)</span></p>
<h4 id="消息鉴别码的安全性">消息鉴别码的安全性</h4>
<h5 id="如何是攻破一个mac方案">如何是攻破一个MAC方案？</h5>
<p>如果敌手能够输出任意消息以及标记，满足：</p>
<p>1.t是消息m的有效标记，即Vrfy(m,t)=1</p>
<p>2.敌手在之前没有获得过m的MAC标记（重放攻击并不被认为是攻破了消息鉴别码）</p>
<h5 id="消息鉴别码实验mac-forge_apin">消息鉴别码实验<span class="math inline">\(Mac-forge_{A,\Pi}(n)\)</span></h5>
<p>1.运行Gen获得一个随机密钥k</p>
<p>2.敌手获得输入值<span class="math inline">\(1^n\)</span>,并能够访问预言机<span class="math inline">\(Mac_k()\)</span>,最后输出一对(m,t)的值，并用<span class="math inline">\(Q\)</span>表示所有<span class="math inline">\(A\)</span>对预言机的询问集合</p>
<p>3.实验输出结果为1，当且仅当Vrfy(m,t)=1,<span class="math inline">\(m\notin Q\)</span></p>
<p>如果没有敌手能在上述实验中以不可忽略概率成功，则认为Mac是安全的</p>
<p>消息认证码<span class="math inline">\(\Pi
=(Gen，Mac，Vrfy)\)</span>在自适应选择消息攻击下是不可避免的或者安全的，如果对所有PPT敌手A，都有一个不可忽略函数negl使得<span class="math inline">\(Pr[Mac-forge_{A,\Pi}(n)=1]\leq
negl(n)\)</span></p>
<p>一个安全的MAC可以确保对手不能在任何以前从未进行过身份验证的新消息上生成有效的标记。</p>
<p>然而上面的定义只能保证在面对新消息时敌手不能产生一个合法的标记，但是并不能保证在原先见过的消息中不能产生一个合法的新标记。一个强安全的MAC可以破解如上的弱点。</p>
<h5 id="定义一个相似的实验叫做mac-sforge_apin">定义一个相似的实验叫做<span class="math inline">\(Mac-sforge_{A,\Pi}(n)\)</span></h5>
<p>1.产生一个随机的k</p>
<p>2.2.敌手获得输入值<span class="math inline">\(1^n\)</span>,并能够访问预言机<span class="math inline">\(Mac_k()\)</span>,最后输出一对(m,t)的值，并用<span class="math inline">\(Q\)</span>表示所有<span class="math inline">\(A\)</span>对预言机的询问的对的集合，这里的对指的是消息m和对应的标记t</p>
<p>3.实验输出结果为1，当且仅当<span class="math inline">\(Vrfy_k(m,t)=1,(m,t)\notin Q\)</span>,写作<span class="math inline">\(Mac-sforge_{A,\Pi}(n)=1\)</span></p>
<p>一个MAC是强的，如果对所有PPT敌手A，有<span class="math inline">\(Pr[Mac-sforge_{A,\Pi}(n)=1]\leq
negl(n)\)</span></p>
<p>如果有时候需要发相同的消息，但是该消息已经在原先被发送过了，这样接收者在收到这个消息时会拒绝这样的消息。解决方案有如下两种：</p>
<p>第一种是在加密过程中加入序列号，对i||m进行加密</p>
<p>第二种是加入一个时间戳，将时间戳给负在加密过程中</p>
<h4 id="构造安全mac">构造安全MAC</h4>
<p>构造一个定长的MAC：</p>
<p>用Gen生成一个密钥k，存在一个函数l，Mac只对<span class="math inline">\(m \in
\{0,1\}^{l(n)}\)</span>有定义，我们把这种加密称作对消息长度为l(n)的消息的定长MAC。</p>
<p>如果MAC的标记t是通过一个PRF获得的，那么对于一个原先未经身份验证的消息伪造标记需要对手在一个新的输入上正确猜测PRF的输出，然而这对任何PPT的对手都是不可行的。</p>
<p>于是可以进行以下构造：</p>
<p>Mac：在输入key <span class="math inline">\(k\in
\{0,1\}^n\)</span>,消息<span class="math inline">\(m
\in\{0,1\}^n\)</span>,输出<span class="math inline">\(t:=F_k(m)\)</span></p>
<p>Vrfy:在输入key <span class="math inline">\(k\in
\{0,1\}^n\)</span>,消息<span class="math inline">\(m
\in\{0,1\}^n\)</span>,标记t$ {0,1}^n$,输出1 iff <span class="math inline">\(t=F_k(m)\)</span></p>
<h4 id="对长消息进行身份验证">对长消息进行身份验证</h4>
<p>对长消息分块后分别进行MAC，在ppt中提到了三种方式，但都是不安全的，具体内容可以重新阅读ppt；通常用的方式是CBC-MAC，但在对不同长度的消息进行身份验证时可能也是不安全的，在这种情况下可以使用CBC-MAC的变体，具体内容在ppt没有提及。</p>
<h4 id="cbc-mac">CBC-MAC</h4>
<p>令F是一个PRF，固定长度函数l：</p>
<p>Mac:k，m=l(n)·n</p>
<p>把m分成等长的块：<span class="math inline">\(m=m_0m_1...m_l\)</span></p>
<p>令<span class="math inline">\(t_0:=0^n\)</span>,然后从i=1到l:</p>
<p><span class="math inline">\(t_i:=F_k(f_{i-1}\oplus m_i)\)</span></p>
<p>输出<span class="math inline">\(t_l\)</span>作为标签</p>
<p>Vrfy:输入是k，m，t 如果m的长度不是l(n)·n,输出0，否则当且仅当<span class="math inline">\(t=Mac_k(m)\)</span>时输出1.</p>
<h4 id="cbc-mac-v.s.-cbc-mode-encryption">CBC-MAC v.s. CBC-mode
encryption</h4>
<p>MAC不适用一个随机的初始串IV，并且只输出最后一个块</p>
<h4 id="身份验证的加密-authenticated-encryption">身份验证的加密
Authenticated Encryption</h4>
<p>目的是同时完成对消息的加密和对身份的验证</p>
<p>A private-key encryption is an authenticated encryption scheme if it
is CCA-secure and
unforgeable.即一个私钥加密方案是身份验证加密如果他是CCA安全的并且是不可伪造的</p>
<h4 id="cca安全">CCA安全</h4>
<p>CCA不可分辨性实验：</p>
<p><span class="math inline">\(Privk^{cca}_{A,\Pi}(n)\)</span>:</p>
<p>1.通过Gen(<span class="math inline">\(1^n\)</span>)生成一个密钥k</p>
<p>2.敌手给定输入<span class="math inline">\(1^n\)</span>,也可以访问神预机的加密和解密<span class="math inline">\(Enc_k,Dec_k\)</span>,输出一对等长消息<span class="math inline">\(m_0,m_1\)</span></p>
<p>3.随机选择一个比特位，然后生成挑战密文<span class="math inline">\(c\gets Enc_k(m_b)\)</span>并发送给A</p>
<p>4.敌手继续访问神预机，但是不允许对挑战密文本身进行询问。最终，敌手输出b'.如果b=b',则输出1，否则输出0.</p>
<p>一个加密方法在选择明文攻击下有完美不可分辨性，或者CCA安全，如果对所有的PPT敌手都有一个可忽略函数negl，有</p>
<p><span class="math inline">\(Pr[Privk^{cca}_{A,\Pi}(n)=1]\leq
\frac{1}{2}+negl(n)\)</span></p>
<p>到目前为止所有提到的加密方案都不是CCA安全的。CCA安全意味着不可延展性，如果敌手想去修改一个密文，要么这个密文是不合法的，要么是一个和原先的明文没有任何关系的明文所对应的密文。</p>
<h4 id="消息完整性实验">消息完整性实验</h4>
<p><span class="math inline">\(Enc-forge_{A,\Pi}(n)\)</span>:</p>
<p>1.通过Gen(<span class="math inline">\(1^n\)</span>)生成一个密钥k</p>
<p>2.敌手给定输入<span class="math inline">\(1^n\)</span>,也可以访问神预机的加密<span class="math inline">\(Enc_k\)</span>,输出一个密文c</p>
<p>3.令<span class="math inline">\(m=Dec_k(c)\)</span>,令Q是A所有询问结果的集合
这个实验输出1当且仅当(1).$m<span class="math inline">\(,即解密失败
(2).\)</span>m Q$(即m还没有被询问过)</p>
<p>一个私钥加密方案是不可伪造的如果对所有的PPT敌手，都有一个可忽略函数negl使得</p>
<p><span class="math inline">\(Pr[Enc-forge_{A,\Pi}(n)=1]\leq
negl(n)\)</span></p>
<h4 id="构造ae">构造AE</h4>
<p>基础想法是结合一个CPA安全加密方案和一个MAC方案来构造AE。有三种方法来实现这个想法：
令<span class="math inline">\(\Pi_E=(Enc,Dec)\)</span>是任意一个CPA安全的加密方案，<span class="math inline">\(\Pi_M=(Mac,Vrfy)\)</span>是任意一个强MAC的方案</p>
<h5 id="encrypt-and-authenticate.">Encrypt-and-authenticate.</h5>
<p>发送方和接受方使用同样的密钥</p>
<p><span class="math inline">\(k_E\gets^{\$}\{0,1\}^n\)</span>,<span class="math inline">\(k_M\gets^{\$}\{0,1\}^n\)</span></p>
<p>对于消息m，发送者计算</p>
<p><span class="math inline">\(c\gets Enc_{k_E}(m),t\gets
Enc_{k_M}(m)\)</span></p>
<p>把<span class="math inline">\((c,t)\)</span>发送给接收者</p>
<p>接收者解密c获得m，假设没有错误，这时再验证标记t，如果<span class="math inline">\(Vrfy(m,t)=1\)</span>,则输出m，否则输出error。</p>
<p>缺点：消息保密不一定受到保护（因为安全的MAC不保证任何保密）。具体来说，加密和身份验证方案对于选择明文攻击可能是不安全的（因为在实践中使用的大多数MAC都是确定性的）。</p>
<h5 id="authenticate-then-encrypt">Authenticate-then-encrypt</h5>
<p>发送方和接受方使用同样的密钥</p>
<p><span class="math inline">\(k_E\gets^{\$}\{0,1\}^n\)</span>,<span class="math inline">\(k_M\gets^{\$}\{0,1\}^n\)</span></p>
<p>对于消息m，发送者计算</p>
<p><span class="math inline">\(t\gets Enc_{k_M}(m),c\gets
Enc_{k_E}(m||t)\)</span></p>
<p>把<span class="math inline">\((c,t)\)</span>发送给接收者</p>
<p>接收者解密c获得m||t，假设没有错误，这时再验证标记t，如果<span class="math inline">\(Vrfy(m,t)=1\)</span>,则输出m，否则输出error。</p>
<p>缺点：密文完整性没有得到保护，因此敌手可以操纵密文，此外，接受者必须先解密密文，才能获知消息是否真实。这种方案不应该被使用</p>
<h5 id="encrypt-then-authenticate">Encrypt-then-authenticate</h5>
<p>Gen:<span class="math inline">\(k_E\gets^{\$}\{0,1\}^n\)</span>,<span class="math inline">\(k_M\gets^{\$}\{0,1\}^n\)</span></p>
<p>Enc:对于消息m，发送者计算<span class="math inline">\(c\gets
Enc_{k_E}(m)\)</span>，<span class="math inline">\(t\gets
Enc_{k_M}(c)\)</span></p>
<p>把<span class="math inline">\((c,t)\)</span>发送给接收者</p>
<p>Dec:输出error如果<span class="math inline">\(Vrfy(c,t)\neq
1\)</span>,否则输出<span class="math inline">\(Dec_{k_E}(c)\)</span>.</p>
<p>如上构造是一种经过认证的加密方案</p>
<p><span class="math inline">\(\Pi_M\)</span>直接说明了如上的加密方案是不可伪造的</p>
<p>如上构造的CCA安全降低到<span class="math inline">\(\Pi_E\)</span>CPA安全性。</p>
<p>这是构造AE的最理想的方法。</p>
<h3 id="哈希函数">哈希函数</h3>
<p>有时候我们需要把一个长字符串压缩成一个短的字符串，这样我们就用到哈希函数（有时叫做消息摘要函数）</p>
<p>我们使用哈希函数进行密码学的实际应用中，应该满足如下两个条件</p>
<p><strong>1.抗碰撞：</strong> 我们应该难以找到<span class="math inline">\(m_0,m_1\)</span>,使得<span class="math inline">\(hash(m_0)=hash(m_1)\)</span></p>
<p><strong>2.完全不可预测：</strong>
应该和一个随机的映射是不可区分的</p>
<p>哈希函数<span class="math inline">\(H^s(x)=H(s,x)\)</span>,一般s是不保密的</p>
<p>哈希函数的形式化定义(Gen,H),其中Gen是一个概率算法，输入一个<span class="math inline">\(1^n\)</span>的安全密钥，输出一个密钥s</p>
<p>H接受输入s和一个字符串x，输出一个对应的串<span class="math inline">\(H^s(x)\in \{0,1\}^{l(n)}\)</span></p>
<h4 id="碰撞检测实验">碰撞检测实验</h4>
<p><span class="math inline">\(Hash-coll_{A,\Pi}(n)\)</span></p>
<p>随机产生一个密钥s，敌手A把密钥s和两个字符串x,x'发送过去，输出1当且仅当<span class="math inline">\(x\neq x&#39;\)</span> and <span class="math inline">\(H^s(x)=H^s(x&#39;)\)</span></p>
<p>一个哈希函数是抗碰撞的如果对所有的PPT敌手都有<span class="math inline">\(Pr[Hash-coll_{A,\Pi}(n)=1]\leq
negl(n)\)</span></p>
<p>在实践中一般不需要这么高的安全性</p>
<p><strong>Second-preimage or taget-collision resistance:</strong></p>
<p>如果给定一个s和一个随机的x，对任何PPT敌手，都不可能找到一个x',使得<span class="math inline">\(x\neq x&#39;\)</span>且<span class="math inline">\(H^s(x)=H^{s}(x&#39;)\)</span></p>
<p><strong>Preimage resistance:</strong></p>
<p>给定一个s和一个随机的y，对任何PPT敌手，都不可能找到一个x，使得<span class="math inline">\(H^s(x)=y\)</span></p>
<p>事实上有:<span class="math inline">\(c.r.\to 2nd p.r. \to
p.r.\)</span></p>
<h4 id="域扩展">域扩展</h4>
<p>用定长的哈希来解决变长的输入：</p>
<p>The Merkle-Damgard Transform</p>
<p>假设一个哈希函数是将一个a+b位的输入压缩成一个a位的输出，构造如下哈希函数：</p>
<p>Gen和原先的哈希函数相同</p>
<p>H接受一个密钥s和一个任意长度字符串x的输入，实行下面两个步骤：</p>
<p><strong>1.划分和填充：</strong></p>
<p>设输入的x的长度是L，其中L的长度小于<span class="math inline">\(2^b\)</span>,把x用0进行若干次填充，使其长度是b的倍数,再将其划分成B+1块，其中$B=
:x_1,x_2,...x_{B+1} $</p>
<p><strong>2.连锁压缩:</strong></p>
<p>选取初始随机向量IV，长度为a</p>
<p>计算<span class="math inline">\(z_i:=h^s(z_{i-1}||x_i)\)</span>,最终输出<span class="math inline">\(H^s(x)=z_{B+1}\)</span></p>
<p><img src="/2024/09/20/Crypto/pic7.png"></p>
<p>如果原哈希函数是抗碰撞的，那么新的哈希函数也是抗碰撞的</p>
<h4 id="mac-and-hash">MAC and HASH</h4>
<p>用哈希函数来扩展MAC域</p>
<p>给定一个定长的MAC和一个任意长度的消息，如何用这个MAC来进行身份验证？</p>
<p>先把这个消息给哈希到一个定长的消息，再对这个消息计算MAC生成标签。</p>
<p>这个MAC是安全的变长MAC如果使用MAC是一个安全的定长MAC且哈希是抗碰撞哈希。</p>
<p><img src="/2024/09/20/Crypto/pic8.png"></p>
<h4 id="用哈希函数构建macs">用哈希函数构建MACs</h4>
<p>HMAC：已证明的安全的构造方法</p>
<p><img src="/2024/09/20/Crypto/pic9.png"></p>
<h4 id="哈希函数常见的攻击方式">哈希函数常见的攻击方式</h4>
<p>1.生日攻击</p>
<p>对于n个不同的数中挑选，只要<span class="math inline">\(\sqrt{n}\)</span>次挑选，就有<span class="math inline">\(\frac{1}{2}\)</span>的概率找到一个碰撞。</p>
<p>由此，一个有n位输出的哈希函数，其安全性就只有<span class="math inline">\(\frac{n}{2}\)</span>位了</p>
<h3 id="one-way-functions-and-hard-core-predicates-单向函数与硬核谓词">One-Way
Functions and Hard-Core Predicates (单向函数与硬核谓词)</h3>
<p>one way
fuctions(OWF)是一类函数，易于计算，但是很难求逆，单向函数的存在实现了很多有用的概念，如PRF、PRG等</p>
<p>定义：</p>
<p>1.易于计算：存在PPT算法<span class="math inline">\(M_f\)</span>来计算f，对所有x，<span class="math inline">\(M_f(x)=f(x)\)</span></p>
<p>2.难于求逆：对任意PPT算法A，存在一个不可忽略函数negl,使得<span class="math inline">\(Pr_{x\gets^{\$} \{0,1\}^n}[A(1^n,f(x))\in
f^{-1}(f(x))]\leq negl(n)\)</span></p>
<p>其中有两个要素，其一是x是均匀随机选取的，而非任意挑选其中一个x，我们求的是平均；其二是我们只需要求出其中一个原像，而不需要所有原像或者最初的x。</p>
<p>可以定义一个实验<span class="math inline">\(Invert_{A,f}(n)\)</span></p>
<p>难以求逆性质要求对所有PPT敌手A，都有一个不可忽略函数negl，使得<span class="math inline">\(Pr[Invert_{A,f}(n)=1]\leq negl(n)\)</span></p>
<h4 id="owf的候选人">OWF的候选人</h4>
<p>目前还不清楚是否存在OWF，但是有几个候选人，至今未找到多项式时间的解决方案，于是暂定其是OWF；</p>
<p>1.两个n位的质数相乘之后进行分解；</p>
<p>2.子集和问题，给定n个数和一个index set
I，给出对应的和，找出原始的I；</p>
<p>3.离散对数问题。输出一个指数p和一个随机元素<span class="math inline">\(g\in \{2,3...p-1\}\)</span>,定义<span class="math inline">\(f_{p,g}=g^{x}\)</span> mod p</p>
<h4 id="hard-core-predicates硬核谓词">Hard-core predicates硬核谓词</h4>
<p>f(x)是OWF能推出从f(x)中我们无法获得任何关于x的信息吗</p>
<p>不一定。</p>
<p>反例：</p>
<p>假设g是一个OWF，f(x1||x2)=x1||g(x2),f是OWF，但是泄露了前面一半的信息</p>
<p>我们用硬核谓词来建模f(x)隐藏的信息</p>
<p>一个函数hc：<span class="math inline">\(\{0,1\}^*\to
\{0,1\}\)</span>是一个函数f的硬核谓词如果hc可以在多项式时间内计算，并且对每一个PPT敌手A都有一个可忽略函数negl使得<span class="math inline">\(Pr_{x\gets \{0,1\}^n}[A(1^n,f(x))=hc(x)]\leq
\frac{1}{2}+negl(n)\)</span></p>
<p>上述定义并不要求f(x)是OWF。</p>
<p>Goldreich-Levin Theorem</p>
<p>假设OWF存在。那么存在一个OWF g和一个g的硬核谓词hc</p>
<p>例如给定OWF f和g，那么hc可以如下构造：</p>
<p><span class="math inline">\(g(x,r)=(f(x),r) for |x|=|r|\)</span></p>
<p><span class="math inline">\(hc(x,r)=\oplus ^n_{i=1}x_i ·
r_i\)</span></p>
<h4 id="用owf构造prg">用OWF构造PRG</h4>
<p>用最小扩展来构造PRG</p>
<p>假设f是一个单向排列，hc是f的一个硬核谓词，那么G(s)=f(s)||hc(s)是一个扩展1位的PRG。</p>
<p>用多项式扩展来构造PRG</p>
<p>每次多生成一位。</p>
<h3 id="number-theory-and-cryptographic-hardness-assumptions-数论与密码学困难度假设">Number
Theory and Cryptographic Hardness Assumptions
(数论与密码学困难度假设)</h3>
<p>a|b:a整除b</p>
<p>余数表示的唯一性：a=qb+r</p>
<p>存在X，Y，使得Xa+Yb=gcd(a,b),且gcd(a,b)是可以以这种形式表示的最小整数。且这种表示不是唯一的，存在无数组XY。</p>
<p>gcd可以用欧几里得算法计算，XY可以用扩展欧几里得算法计算。</p>
<p><span class="math inline">\(gcd_{loop}\)</span>(a, b)： r=0 while (b
<span class="math inline">\(\neq\)</span> 0) { r = a mod b; a = b; b =
r; } return a;</p>
<p>扩展欧几里得方法找到XY：</p>
<p><img src="/2024/09/20/Crypto/pic10.png"></p>
<p>在模运算意义下加减乘运算都封闭</p>
<p>除法运算不封闭</p>
<p>b是模N意义下可逆的：存在c，bc=1 mod N,c称为b的乘法逆元</p>
<p><span class="math inline">\(b^{-1}\)</span>:b在1~N-1里面的唯一的逆元</p>
<p>定义下面的除法操作：<span class="math inline">\([a/b mod N]=[ab^{-1}
mod N]\)</span></p>
<p>因此只要除数的逆元存在，那么除数就是良定义的，ab=cb mod N 就能推出a=c
mod N</p>
<p>b是可逆的当且仅当gcd(b,N)=1</p>
<p>求乘法逆元可以用欧几里得扩展算法。</p>
<h4 id="群论">群论</h4>
<p>很多加密系统都是基于群论的</p>
<p>一个群是一个代数结构，由一个元素集G和一个二元操作符组成的</p>
<p>满足封闭性、满足结合律、有单位元、有逆元</p>
<p>Closure. g, h ∈ G, g ◦ h ∈ G</p>
<p>Existence of an identity. e ◦ g = g = g ◦ e.</p>
<p>Existence of inverses. g ◦ h = e = h ◦ g</p>
<p>Associativity. g1, g2, g3 ∈ G, (g1 ◦ g2) ◦ g3 = g1 ◦ (g2 ◦ g3)</p>
<p>如果是可交换的，那么是阿贝尔群</p>
<p>对于任意整数N，我们可以在模乘法意义下构造一个群吗：可以，<span class="math inline">\(Z^*_N=\{b\in
\{1,...N-1\}|gcd(b,N)=1\}\)</span></p>
<p>所有元素都是与N互质的。这个集合称为N的简化剩余系，而<span class="math inline">\(Z_N\)</span>成为N的完全剩余系。</p>
<h4 id="欧拉phi函数">欧拉phi函数</h4>
<p><span class="math inline">\(\phi(N)=|Z^*_N|\)</span>,<span class="math inline">\(\phi\)</span>成为欧拉phi函数。</p>
<p>有如下定理：</p>
<p>令<span class="math inline">\(N=\Pi_ip_i^{e_i}\)</span>,其中<span class="math inline">\(P_i\)</span>是不同的质数，<span class="math inline">\(e_i\geq 1\)</span>,那么<span class="math inline">\(\phi(n)=\Pi_ip_i^{e^i-1}(p_i-1)\)</span></p>
<p>例如<span class="math inline">\(N=15=3*5，Z^*_N=\{1, 2, 4, 7, 8, 11,
13, 14\}=8=(5-1)(3-1)\)</span></p>
<h4 id="费马欧拉定理">费马欧拉定理：</h4>
<p>对任意N&gt;1 和<span class="math inline">\(a\in Z^*_N\)</span>,<span class="math inline">\(a^{\phi(N)}=1\)</span> mod
N.当N是质数p的时候，<span class="math inline">\(a^{p-1}=1\)</span> mod
p</p>
<p>令G是有限集，m=|G|,是群的阶数，对于任意元素<span class="math inline">\(g\in G,g^m=1\)</span></p>
<p>质数检验：给定N，计算<span class="math inline">\(\sqrt{N}\)</span>,对里面的质数进行计算，看是不是N的因数，要都不是，那么N是质数。</p>
<h4 id="中国剩余定理">中国剩余定理</h4>
<p>令N=pq，pq互质，那么<span class="math inline">\(Z_n\simeq Z_p \times
Z_q\)</span>,<span class="math inline">\(Z_N^* \simeq \Z_p^*\times
Z_q^*\)</span></p>
<p>进一步的，令f是一个从x到<span class="math inline">\(x_p,x_q\)</span>的映射,f(x)=([x mod p],[x mod
q]),那么f是一个同构映射。</p>
<p>令N=<span class="math inline">\(p_1p_2p_3...p_l\)</span>，那么<span class="math inline">\(Z_n\simeq Z_{p_1} \times Z_{p_2} ... \times
Z_{p_l}\)</span>,<span class="math inline">\(Z_n^*\simeq Z_{p_1}^*
\times Z_{p_2}^* ... \times Z_{p_l}^*\)</span></p>
<p><img src="/2024/09/20/Crypto/pic24.png"></p>
<p>这里面9X+35Y=1,得Y=8;7X+45Y=1,得Y=5;5X+63Y=1,得Y=2</p>
<p><img src="/2024/09/20/Crypto/pic11.png"></p>
<p><img src="/2024/09/20/Crypto/pic12.png"></p>
<h5 id="如何找原像">如何找原像</h5>
<p><img src="/2024/09/20/Crypto/pic13.png"> <img src="/2024/09/20/Crypto/pic14.png">
<img src="/2024/09/20/Crypto/pic15.png"></p>
<h4 id="rsa假设">RSA假设</h4>
<p>分解假设认为如下分解问题是困难的：</p>
<p>这个问题通过运行一个多项式时间算法
GenMoudulus来进行实例化，给定输入1^n,输出(N,p,q),其中N=pq，p和q是n位的质数</p>
<p><span class="math inline">\(Factor_{A,GenModulus}(n):\)</span></p>
<p>运行GenModulus<span class="math inline">\((1^n)\)</span>获得(N,p,q)</p>
<p>A给定N输出p' q'</p>
<p>输出1 如果 p'·q'=N</p>
<p>分解问题是困难的如果对于所有PPT敌手都有一个可忽略函数negl使得<span class="math inline">\(Pr[Factor_{A,GenModulus}(n)=1]\leq
negl(n)\)</span></p>
<p>RSA问题是和分解问题及其相关的</p>
<p>The RSA experiment <span class="math inline">\(RSA_{invA,GenRSA}(n)\)</span></p>
<p>运行GenRSA<span class="math inline">\((1^n)\)</span>获得(N,e,d),N是两个n位的质数的乘积，<span class="math inline">\(gcd(e,\phi(N))=1\)</span> 且<span class="math inline">\(ed=1\)</span> mod <span class="math inline">\(\phi(N)\)</span></p>
<p>均匀随机选取一个<span class="math inline">\(y \in Z^*_N\)</span></p>
<p>A给定N,e,y,输出<span class="math inline">\(x \in Z^*_N\)</span></p>
<p>如果<span class="math inline">\(y=x^e\)</span> mod
N,输出1，否则输出0</p>
<p>RSA问题是困难的如果对所有PPT敌手都有一个可忽略函数negl使得<span class="math inline">\(Pr[RSA_{invA,GenRSA}(n)=1]\leq
negl(n)\)</span></p>
<h4 id="循环群中的密码学假设">循环群中的密码学假设</h4>
<h5 id="循环群和生成元">循环群和生成元</h5>
<p>设群的阶数是m，<g>={<span class="math inline">\(g^0,g^1,g^2...g^{i-1}\)</span>}是一个循环群，g是一个生成元,i是最小的正整数，使得<span class="math inline">\(g^i=1\)</span>，i称为g的阶数</g></p>
<p>i总是存在而且小于等于m</p>
<p>如果g的阶数是m，那么g是一个循环群的生成元</p>
<h4 id="离散对数问题和diffie-hellman假设">离散对数问题和diffie-hellman假设</h4>
<p>设G是一个生成元为g，阶数为q的循环群</p>
<p>对群中的任意一个元素h，都存在一个x，使得<span class="math inline">\(g^x=h\)</span></p>
<p>我们把x称为h相对于g的离散对数，写作<span class="math inline">\(x=log_g(h)\)</span></p>
<p>The discrete-logarithm experiment <span class="math inline">\(DLog_{A,\mathcal{G} }\)</span></p>
<p>运行<span class="math inline">\(\mathcal{G}(1^n)\)</span>来获得(G,q,g),其中G是一个生成元为g，阶数为q的循环群</p>
<p>选取随机G中一个元素h</p>
<p>A给定(G,q,g,h),输出x</p>
<p>实验的结果是1，当且仅当<span class="math inline">\(g^x=h\)</span></p>
<p>我们称离散对数问题是困难的，如果对所有PPT敌手都有一个可忽略函数negl使得<span class="math inline">\(Pr[DLog_{A,\mathcal{G} }=1]\leq
negl(n)\)</span></p>
<p>离散对数假设是假设存在一个G，而离散对数问题是困难的。</p>
<h3 id="key-management-and-the-public-key-revolution-密钥管理与公钥加密变革">Key
Management and the Public-Key Revolution (密钥管理与公钥加密变革)</h3>
<h4 id="kdc">KDC</h4>
<p>密钥集散中心：和所有实体之间都有一个初始的密钥，当A想和B交流时，用A的密钥加密消息向KDC发出申请，KDC解密后知道A的请求，于是生成一个新的密钥，分别用A和B的密钥加密后发给A和B，这样A和B就可以用这个新密钥进行通信。</p>
<p>在通信结束后，A和B都把这个密钥销毁。不过这种方法有一个缺点，就是KDC需要保存所有的密钥，如果KDC被攻破，那么所有的密钥都会泄露。</p>
<h4 id="needham-schroeder-key-distribution-protocol">Needham-Schroeder
key-distribution protocol</h4>
<p><img src="/2024/09/20/Crypto/pic16.png"></p>
<p>如何不依赖于KDC来建立一个安全的密钥交换协议？</p>
<h4 id="the-diffie-hellman-key-exchange-protocol">The Diffie-Hellman
key-exchange protocol</h4>
<p>令$ $是一个PPT算法，输入<span class="math inline">\(1^n\)</span>，输出(G,q,g),其中G是一个生成元为g，阶数为q（q=n）的循环群</p>
<p>D-H key-exchange protocol is constructed as follows</p>
<p><img src="/2024/09/20/Crypto/pic17.png"></p>
<p>正确性：<span class="math inline">\(K_A=h_B^x=(g^y)^x=g^{xy}=(g^x)^y=h_A^y=K_B\)</span></p>
<p>安全性：敌手可以看到G,q,g,<span class="math inline">\(h_A\)</span>,<span class="math inline">\(h_B\)</span>，但是不能看到x,y</p>
<p>通过定义实验来证明安全性：</p>
<h4 id="the-key-exchange-experiment-ke_apieavn">The key-exchange
experiment <span class="math inline">\(KE_{A,\Pi}^{eav}(n)\)</span></h4>
<p>两个主体都持有<span class="math inline">\(1^n\)</span>,运行密钥交换协议，产生了一个包含有两者所有暴露信息的文本Trans，并且输出了一个两个主体所共同持有的密钥k</p>
<p>随机选择一位b，如果b=0，那么<span class="math inline">\(\hat{k}:=k\)</span>，否则均匀随机选择<span class="math inline">\(\hat{k}\in \{0,1\}^n\)</span></p>
<p><span class="math inline">\(\mathcal{A}\)</span> 给定Trans和<span class="math inline">\(\hat{k}\)</span>,输出一位b'</p>
<p>实验输出1，当且仅当b=b'</p>
<p>这个密钥交换协议在有窃听者在场的情况下是安全的，当且仅当如果对所有PPT敌手<span class="math inline">\(\mathcal{A}\)</span>，都有一个可忽略函数negl使得<span class="math inline">\(Pr[KE_{A,\Pi}^{eav}(n)=1]\leq
\frac{1}{2}+negl(n)\)</span></p>
<p>为了简化这个问题，随机生成的一个k修改为从G中随机选一个元素，这样问题被重新定义为<span class="math inline">\(\hat{KE}^{eav}_{A,\Pi}(n)\)</span></p>
<h5 id="如果和mathcalg相关判定性diffie-hellman问题是困难的那么这个密钥交换协议是安全的">如果和<span class="math inline">\(\mathcal{G}\)</span>相关判定性diffie-hellman问题是困难的，那么这个密钥交换协议是安全的。</h5>
<p><img src="/2024/09/20/Crypto/pic18.png">
DH密钥很容易受到中间人攻击，因此在实践中不单独使用</p>
<h3 id="公钥加密">公钥加密</h3>
<p>一个公钥加密方案可以写成一个PPT算法的三元组</p>
<p>Gen：输入<span class="math inline">\(1^n\)</span>，输出一个公钥pk和一个私钥sk</p>
<p>Enc：输入pk和一个消息m，输出密文<span class="math inline">\(c\gets
Enc_{pk}(m)\)</span></p>
<p>Dec：输入sk和密文c，输出消息m，<span class="math inline">\(m:=Dec_{sk}(c)\)</span></p>
<p>在有窃听者的情况下设计实验来考虑公钥加密的安全性：</p>
<h4 id="the-eavesdropping-indistinguishability-experiment-pubkeav_apin">The
eavesdropping indistinguishability experiment <span class="math inline">\(PubK^{eav}_{A,\Pi}(n)\)</span></h4>
<p>运行Gen(1^n)获得(pk,sk)</p>
<p>敌手给定公钥pk，输出两个消息m0,m1</p>
<p>随机选择一个比特位b，生成密文<span class="math inline">\(c\gets
Enc_{pk}(m_b)\)</span>，把c发送给敌手A,c称为挑战密文</p>
<p>A输出一个比特b'，实验输出1当且仅当b=b'</p>
<p>一个公钥加密方案在窃听者存在时进行无法区分的加密，如果对所有PPT敌手A，都有一个可忽略函数negl使得<span class="math inline">\(Pr[PubK^{eav}_{A,\Pi}(n)=1]\leq
\frac{1}{2}+negl(n)\)</span></p>
<p>与私钥加密不同，<strong>如果一个公钥加密方案在窃听者存在的情况下具有难以区分的加密，那么它是CPA安全的</strong>，即对CPA对手具有难以区分的加密。</p>
<p>因为(1)
A是pk（用于加密），(2)Enc是公开已知的。因此，A可以自己加密任何消息，这相当于有一个加密神预机。</p>
<p><strong>如果一个公钥加密方案是CPA安全的，那么他也有对多条消息加密的不可区分性。</strong></p>
<p>CPA安全的定长加密方案意味着CPA安全的任意长度加密方案。</p>
<h4 id="用如下实验来定义cca安全pubkcca_apin">用如下实验来定义CCA安全<span class="math inline">\(PubK^{cca}_{A,\Pi}(n)\)</span></h4>
<p>Gen(<span class="math inline">\(1^n\)</span>)获得(pk,sk)</p>
<p>敌手给定公钥pk，可以访问解密预言机<span class="math inline">\(Dec_{sk}(·)\)</span>,输出一对等长的消息m0,m1</p>
<p>随机选择一个比特位b，生成密文<span class="math inline">\(c\gets
Enc_{pk}(m_b)\)</span>，把c发送给敌手A,c称为挑战密文</p>
<p>A继续访问解密预言机，但是不允许对挑战密文本身进行询问。最终，敌手输出b'，实验输出1当且仅当b=b'</p>
<p>一个公钥加密方案是CCA安全的，如果对所有的PPT敌手A，都有一个可忽略函数negl使得<span class="math inline">\(Pr[PubK^{cca}_{A,\Pi}(n)=1]\leq
\frac{1}{2}+negl(n)\)</span></p>
<p>类似于cpa安全的公钥加密，我们有：<strong>如果加密方案是cca安全的，那么在chosen
ciphertext attacks下也有无法区分的（多个）加密。</strong></p>
<p><strong>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!have trouble in
understanding the following content</strong></p>
<p><strong>但是和公钥加密的CPA安全不同，将定长的CCA安全的公钥加密方案扩展到任意长度的消息并不是CCA安全的</strong></p>
<p>因为敌手可以对挑战密文块重新排序，从而获得一个新的密文。</p>
<p>公钥加密的优点：</p>
<p>密钥分发更加简单，对于用户数量未知的开放系统更加便捷。</p>
<p>公钥加密的缺点：</p>
<p>加密速度慢2-3个数量级，公钥加密通常具有更大的密文扩展（因此可能需要存储/传输更多的位）。</p>
<h4 id="hybrid-encryption-and-the-kemdem-paradigm混合加密和两种范式">Hybrid
Encryption and the KEM/DEM Paradigm混合加密和两种范式</h4>
<p>为了同时利用公钥加密和私钥加密的优点，避免两者的缺点，提出了混合加密的概念</p>
<p><img src="/2024/09/20/Crypto/pic19.png"></p>
<h5 id="the-key-encapsulation-mechanism-kem密钥封装机制">The
key-encapsulation mechanism (KEM)密钥封装机制</h5>
<p>data-encapsulation mechanism
(DEM)是一个私钥加密方案，称为数据封装机制</p>
<p><img src="/2024/09/20/Crypto/pic20.png"></p>
<h4 id="cdhddh-based-encryption">CDH/DDH-Based Encryption</h4>
<p><strong>El Gamal encryption scheme</strong></p>
<p>令<span class="math inline">\(\mathcal{G}\)</span>是一个PPT算法，输入<span class="math inline">\(1^n\)</span>，输出(G,q,g),其中G是一个生成元为g，阶数为q（q=n）的循环群</p>
<p>Gen：输入<span class="math inline">\(1^n\)</span>，运行<span class="math inline">\(\mathcal{G}(1^n)\)</span>获得(G,q,g),随机选择一个x，计算h=<span class="math inline">\(g^x\)</span>,公钥是&lt;G,q,g,h&gt;,私钥是&lt;G,q,g,x&gt;,消息空间是G</p>
<p>Enc:输入公钥&lt;G,q,g,h&gt;和一个消息m，随机选择一个y,输出密文&lt;<span class="math inline">\(g^y\)</span>,<span class="math inline">\(h^y·m\)</span>&gt;</p>
<p>Dec:输入私钥&lt;G,q,g,x&gt;和密文&lt;<span class="math inline">\(c_1,c_2\)</span>&gt;，输出<span class="math inline">\(\hat{m}:=c_2/c_1^x\)</span></p>
<p>如果DDH问题相对于<span class="math inline">\(\mathcal{G}\)</span>是困难的，那么El
Gamal加密方案是CPA安全的。</p>
<p>证明见书本**</p>
<p>但是不是CCA安全的</p>
<h4 id="rsa加密">RSA加密</h4>
<h5 id="plain-rsa">plain RSA</h5>
<p>RSA加密基于如下trapdoor one-way function</p>
<p><strong>“one way”</strong>:给定一个均可见的整数e和N，对于任意<span class="math inline">\(m\in Z_N^*\)</span>,容易计算c=[<span class="math inline">\(m^e\)</span> mod N]，但是从c计算m是困难的</p>
<p><strong>"trapdoor
information"</strong>：如果已知N的分解，那么从c计算m是容易的</p>
<p>RSA密钥生成算法运行如下：</p>
<h6 id="genrsa">GenRSA</h6>
<p>输入安全参数1^n</p>
<p>输出N,e,d</p>
<p>1.(N,p,q)<span class="math inline">\(\gets\)</span> GenModulus(<span class="math inline">\(1^n\)</span>)</p>
<p>2.<span class="math inline">\(\phi(N)=(p-1)(q-1)\)</span></p>
<p>3.选择一个e，使得gcd(e,<span class="math inline">\(\phi(N)\)</span>)=1</p>
<p>4.计算d:=[<span class="math inline">\(e^{-1}\)</span> mod <span class="math inline">\(\phi(N)\)</span>]</p>
<p>5.Return (N,e,d)</p>
<p>给定密钥生成算法GenRSA，RSA加密方案是如下的三元组：</p>
<h4 id="the-plain-rsa-encryption-scheme">The plain RSA encryption
scheme</h4>
<p>Gen:运行GenRSA(<span class="math inline">\(1^n\)</span>)获得(N,e,d),公钥是(N,e),私钥是(N,d)</p>
<p>Enc：输入公钥pk=(N,e)和一个消息m<span class="math inline">\(\in
Z^*_N\)</span>，输出密文c=[<span class="math inline">\(m^e\)</span> mod
N]</p>
<p>Dec:输入私钥sk=(N,d)和密文<span class="math inline">\(c\in
Z^*_N\)</span>，输出<span class="math inline">\(m:=c^d\)</span> mod
N</p>
<p>为什么plain RSA是不安全的：</p>
<p>plain
RSA不是CPA安全的，或者说在有窃听者在场的情况下没有不可区分的加密</p>
<p><strong>No deterministic public-key encryption scheme is
CPA-secure.</strong></p>
<p>因为缺少随机性，敌手可以让其加密两条消息m0和m1，然后将结果与挑战密文相互比较</p>
<p>RSA加密的安全性的先决条件是要求被加密的m是随机选择的，但是在这里m不是从<span class="math inline">\(Z^*_N\)</span>中均匀随机选择的，c也不是均匀分布的，因此RSA假设并不适用于plain
RSA</p>
<h4 id="padded-rsa">Padded RSA</h4>
<p>为了克服如上缺点，使用了填充RSA的方法。</p>
<p>在加密之前，消息被“随机填充”（或随机映射）到<span class="math inline">\(Z_N^*\)</span>中的一个长消息。长随机消息被输入加密算法并生成密文。</p>
<p>要解密，需要将密文输入解密算法，并使用“去填充”操作从输出中恢复原始消息（这需要映射是可逆的）。</p>
<p>安全性主要取决于所使用的特定映射。</p>
<p>RSA Laboratories Public-Key Cryptography Standard (PKCS)</p>
<p><img src="/2024/09/20/Crypto/pic2·.png"></p>
<p>如果r的长度是N的一半，那么它是CPA安全的</p>
<p>optimal asymmetric encryption padding (OAEP)</p>
<p><img src="/2024/09/20/Crypto/pic1·.png"></p>
<h3 id="digital-signature-schemes-数字签名机制">Digital Signature
Schemes (数字签名机制)</h3>
<p>与MAC一样都是用来保证消息完整性的，区别在于数字签名是所有人都可以进行验证的。数字签名还提供了不可抵赖性non-repudiation。</p>
<p>数字签名不如MAC高效，一个可能的方式是用哈希-签名范式，把一个长消息哈希，再签名。</p>
<h4 id="数字签名方案">数字签名方案：</h4>
<p>一个数字签名方案包含三个PPT算法：</p>
<p>key-generation algorithm:输入<span class="math inline">\(1^n\)</span>，输出一个公钥pk和一个私钥sk</p>
<p>signing algorithm:输入私钥sk和一个消息m，输出签名<span class="math inline">\(\sigma\)</span>,写作<span class="math inline">\(\sigma\gets Sign_{sk}(m)\)</span></p>
<p>verification algorithm:输入公钥pk，一个消息m和一个签名<span class="math inline">\(\sigma\)</span>，输出1或0，写作<span class="math inline">\(Vrfy_{pk}(m,\sigma)\)</span></p>
<p>定义如下实验<strong><span class="math inline">\(Sig-forge_{A,\Pi}\)</span>(n)</strong>:</p>
<p>运行Gen(1^n)获得(pk,sk)</p>
<p>敌手A给定pk，可以访问加密预言机Sign_{sk}(·)，令Q是A所有询问结果的集合</p>
<p>A输出一个消息m和一个签名<span class="math inline">\(\sigma\)</span></p>
<p>A获胜如果<span class="math inline">\(Vrfy_{pk}(m,\sigma)=1\)</span>且m<span class="math inline">\(\notin\)</span> Q中,输出1</p>
<p>一个数字签名方案是在自适应选择消息攻击下不可伪造的，如果对所有PPT敌手A，都有一个可忽略函数negl使得<span class="math inline">\(Pr[Sig-forge_{A,\Pi}(n)=1]\leq
negl(n)\)</span></p>
<p><strong>Theorem</strong></p>
<p>如果<span class="math inline">\(\Pi\)</span>是一个数字签名方案，那么<span class="math inline">\(\Pi\)</span>是一个长度为l的安全的数字签名方案，<span class="math inline">\(\Pi_H\)</span>是一个长度为l的抗碰撞的哈希函数，那么如上构造的哈希-签名方案就是一个任意长度消息的安全的数字签名方案。</p>
<h4 id="rsa签名">RSA签名</h4>
<p>Plain RSA签名是不安全的</p>
<p>Gen:运行GenRSA(<span class="math inline">\(1^n\)</span>)获得(N,e,d),公钥是(N,e),私钥是(N,d)</p>
<p>Sign:输入私钥sk=(N,d)和一个消息m，输出签名<span class="math inline">\(\sigma:=m^d\)</span> mod N</p>
<p>Vrfy:输入公钥pk=(N,e)和一个消息m和一个签名<span class="math inline">\(\sigma\)</span>，输出1当且仅当<span class="math inline">\(\sigma^e\)</span> mod N=m</p>
<p>攻击方式：</p>
<p>1.无消息攻击，一个签名是合法的当且仅当<span class="math inline">\(\sigma^e\)</span> mod N=m</p>
<p>为了生成一个合法的签名，敌手任意选择了一个签名<span class="math inline">\(\hat{\sigma} \in Z_N^*\)</span>，然后计算<span class="math inline">\(\hat{m}=\hat{\sigma}^e\)</span> mod
N,最后输出(<span class="math inline">\(\hat{m}\)</span>,<span class="math inline">\(\hat{\sigma}\)</span>)</p>
<p>造成这个漏洞的原因是容易求逆，在已知签名的情况下很容易求出消息</p>
<p>2.由RSA签名的可塑性来伪造m的签名</p>
<p>找到两个消息m0和m1，使得<span class="math inline">\(m_0·m_1\)</span>
mod N=m，那么<span class="math inline">\(\sigma_0·\sigma_1\)</span> mod
N=1，那么<span class="math inline">\(\sigma_0\)</span>和<span class="math inline">\(\sigma_1\)</span>都是合法的签名</p>
<h4 id="rsa-fdh-signature-scheme">RSA-FDH signature scheme</h4>
<p>为了避免如上伪造，可以在签名前对消息进行一个变换H(·)，其中这个变换要满足1.单向函数，2.不可塑性，3.抗碰撞</p>
<p>基于如上条件，构造了RSA-FDH signature scheme</p>
<p>H是一个随机函数，把输入映射到<span class="math inline">\(Z_N^*\)</span>上。</p>
<p>Gen:运行GenRSA(<span class="math inline">\(1^n\)</span>)获得(N,e,d),公钥是(N,e),私钥是(N,d)</p>
<p>Sign:输入私钥sk=(N,d)和一个消息m，输出签名<span class="math inline">\(\sigma:=H(m)^d\)</span> mod N</p>
<p>Vrfy:输入公钥pk=(N,e)和一个消息m和一个签名<span class="math inline">\(\sigma\)</span>，输出1当且仅当<span class="math inline">\(\sigma^e\)</span> mod N=H(m)</p>
<p>If the RSA problem is hard relative to GenRSA and H is modeled as a
random oracle, then RSA-FDH signature is secure.</p>
<h4 id="来自离散对数问题的签名">来自离散对数问题的签名</h4>
<h5 id="the-identification-scheme">The Identification Scheme</h5>
<p>身份识别方案是用来向别人证明自己身份的，在这里，我们将注意力限制在公钥识别方案上。</p>
<p>在公钥设置中，识别方案允许你向某人（称为验证者）证明您是与特定公钥相对应的那个人。</p>
<p>我们通过证明我们知道与公钥相关的私钥来实现这一点。</p>
<p>我们的问题是，如何不告诉验证者我们的私钥就能证明我们知道它。</p>
<p>方案1.证明者把<span class="math inline">\(x\in
Z_q\)</span>发送给验证者，验证者计算y=<span class="math inline">\(g^x\)</span>，看是否与公钥相同，但是会泄露私钥x</p>
<p>方案2.<strong>the Schnorr identification scheme</strong></p>
<p>证明者随机选择一个b<span class="math inline">\(\gets
Z_q\)</span>,计算I=<span class="math inline">\(g^b\)</span>,把I发送给验证者</p>
<p>验证者随机选择一个a<span class="math inline">\(\gets
Z_q\)</span>(call a challenge)，计算y=<span class="math inline">\(g^a\)</span>，把y发送给证明者</p>
<p>证明者计算X=[ax+b mod q]，把X发送给验证者</p>
<p>验证者接受当且仅当<span class="math inline">\(y^a*I=g^X\)</span></p>
<p><img src="/2024/09/20/Crypto/pic22.png"></p>
<p>我们说这个认证方案是安全的，如果没有PPT敌手可以通过上述的验证方案来获得关于私钥的任何信息。</p>
<p>证明方案有如下两种：</p>
<ol type="1">
<li>constructing a simulator S that does NOT know x, but can simulate
the view or transcript (i.e. the messages it sees) of an eavesdropper in
the scheme.</li>
</ol>
<p>(2)proving NO PPT adversaries can differentiate the simulated view
and the real view.</p>
<p><img src="/2024/09/20/Crypto/pic21.png"></p>
<h4 id="the-schnorr-signature-scheme">The Schnorr signature scheme</h4>
<p>一个认证方案可以通过如下步骤转换为一个签名方案：</p>
<p>The signer acts as a prover, runs the identification scheme by
itself.</p>
<p>It generates a challenge a by applying some random function H to I
and m.</p>
<p>It generates the correct response X and uses (a, X) as the signature
of m.</p>
<p>The Fiat-Shamir
transform：把上述的三轮交互式验证转换为两轮的非交互式验证。</p>
<p>H是一个哈希函数，这个变换被用来构建非交互式的加密协议</p>
<p>签名(a,X)被限制到了一个特定的消息m，m的改变会导致a的巨大变化(a=H(m,I))</p>
<p>签名是难以伪造的，因为不知道私钥</p>
<p><img src="/2024/09/20/Crypto/pic23.png"></p>
<h3 id="结语">结语：</h3>
<p><strong>给分情况</strong> ： 期中考试：20% 100分 平时作业：40%
100+100+90+100 期末考试：40% 82分 总评92分</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2024/09/20/Crypto/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/09/18/updating_in_9-18-2024/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">updating in 9-18-2024</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> MorningStar
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="GaoGe&#39;s Homepage"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat1.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>